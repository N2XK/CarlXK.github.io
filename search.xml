<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[近期训练计划]]></title>
    <url>%2F2021%2F09%2F11%2F%E8%BF%91%E6%9C%9F%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[力量训练频度：每周两次时间：周一到周五之间时间不定，尽量周二和周四计划： 第一次 深蹲 60KG 10，80KG 10，100KG 5，110KG 3，120KG 2 * 2 尝试 130KG PR 颈后推 30KG 8*4 跳箱 10*4 第二次 硬拉 60KG 10，80KG 10，100KG 5，120KG 3，140KG 3，150KG 2 尝试 160KG PR 抓举 40 * 5 有氧训练跑步5~10公里，每周1~2次 养生锻炼八段锦：每天一遍 两手托天理三焦，一上一下为一次，一共6次左右开弓似射雕，一左一右为一次，一共3次调理脾胃须单举，一左一右为一次，一共3次五劳七伤往后瞧，一左一右为一次，一共3次摆头摆尾去心火，一左一右为一次，一共3次两手攀足固肾腰，一上一下为一次，一共6次攒拳怒目增气力，一左一右为一次，一共3次背后七颠百病消，一起一落为一次，一共7次]]></content>
      <categories>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>健身</tag>
        <tag>跑步</tag>
        <tag>养生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-新一分钟经理人]]></title>
    <url>%2F2021%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20%E6%96%B0%E4%B8%80%E5%88%86%E9%92%9F%E7%BB%8F%E7%90%86%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[读书笔记-新一分钟经理人 1. 一分钟目标共同制定工作目标，并清楚简洁地描述出来，明确好的工作表现的标准 一个工作目标、衡量标准和完成期限，应该用一到两段话说明白，读一遍大概花一分钟。把目标简洁地写下来，便于查阅并能把精力集中在最重要的部分 2/8原则，对20%的关键任务设定一分钟目标，可能一共只有3到5个工作目标 每一项清楚描述出来，一个目标大概一页纸，遵循SMART原则 规定每天用几分钟时间重温自己最重要的目标，用一分钟审视自己的表现，审视是否与目标一致若与目标不一致，反思自己的工作表现，以便调整 引导员工自己思考 不把猴子背在自己身上 在哪里，要去哪里，差距有多大，怎么去？ 为什么这么有效 把问题浮到水面上 目标透明，量化，回顾(参考OKR) 对优秀的人一起设定一分钟目标，其余他会自己搞定 对潜力者一起设定目标并定期回顾 2. 一分钟称赞前半分钟 及时称赞员工 及时激励，发现员工做对了事情就立即给予称赞，而不是等到考核 及时的表扬会鼓舞士气，延时的鼓励会让积极性受损 从心理学的角度来说，人是需要被认可的 告诉他们对在哪里–要说的非常具体 说明你对员工做的事情很了解，很关心他的状况 告诉他们这件事情做对之后，会让你感到多么高兴，对整个团队和其他同事又会有多大帮助。 价值赞美 停顿一会儿 沉默几秒，让他们静静地体会做对事情带来的喜悦 后半分钟 鼓励他们以后继续这样做 明确说明你对他们有信心，并会支持他们获得成功 为什么这么做有效 训练成功者最重要的是发现他们做对了的事情——开始也许只是大概做对，接着要逐渐引导他们做得越来越完美 示例：鼓励小孩子走路，从摇摇晃晃到站起来，鼓励最有效 示例：教孩子说会喝水，从指着水，到说水，到喝水 设立一系列小目标，可以帮助人们更顺利的完成整项工作 示例：游戏的新手村任务引导，不断完成小目标直到会玩这个游戏，及时的激励和反馈会激发潜力 被挑毛病的、饱受打击的人总是尽量少做事情 原因在于领导者总是在挑毛病，总是在留意哪些事情未到达期望 惩罚不如帮助员工重新设定目标，更正行为，确保其了解该做什么以及怎么做 3. 一分钟改正开始前：确认和员工设定的目标是否阐述清楚，如果没有，主动承担责任，并再次详细说明工作目标，这会让人做事很公平前半分钟 错误发生后立即进行更正 反馈应该及时 工作出了差错，不更正只称赞于事无补。每个人都不喜欢经常被人指出错误，但一次‘更正’可以帮助员工重回工作轨道并完成工作目标，公司和个人才能实现双赢 确认既有的事实，分析错在哪里–要说的非常具体 告诉他们这件事带给你的感受，以及对工作成果可能造成的影响 停顿一会儿 沉默几秒，让他们审视锁犯的错误 后半分钟 告诉对方，他们的实际能力比这次表现出来更强， 你认为他们很不错 特别期待再跟我碰面——只要不是因为犯了同样的错误 告诉对方，你对他们有信心，任然信任他们 更正过去，整件事就过去了 为什么这么做有效 反馈应该是及时的，一旦发现下属做错事，立即指出来 及时提出意见，就可以一个一个地处理问题，被批评的人也不会觉得那么难接受，反而会听进心里去 后半分钟称赞是很重要的一部分 我们的目的是帮助人们建立自尊自信，而不是贬低他们的价值。 人格受到伤害时，哪怕扭曲事实，人们也会为自己和自己的行为开脱。一旦形成防备心态，就很难听得进去 区分行为和价值区，指出行为的错误，不贬低员工的人格，最后肯定他们的价值 你转身离开后，员工会更留意自己的行为，而不是跟同事抱怨自己碰了钉子或是质疑你的领导方式 “严厉”在前，“和气”在后 示例：皇帝和丞相的故事，皇帝先和气后严厉被推翻，丞相先严厉后和气被推选为皇帝 示例：棒球运动运表现不佳，先指出问题，再肯定其能力比表现强，调整后再上场 真正尊重和关心下属，才会获得真正的成功 必须表现得严厉，才是真正关心别人。但只是就事论事，从不针对人。犯错不可怕，不吸取教训才会导致真正的挫败 不是操控，是真的关心 4. 一分钟管理体系### 5. 一分钟经理人座右铭通过发现别人做对的事，来帮助他们充分发挥潜力 管理的本质就是激发他人的善意 最好的投资，就是把时间花在人的身上 培养人 每个人都可能成功，有些人貌似失败者，但人不可貌相 爱因斯坦会拿电话簿查自己家电话号码 拿出一分钟，重温你的目标，审视你的工作表现，看看你的行为与目标是否一致 桌面卡片 我们不仅能够表现自己，还能够管理自己 人是值得信任的，是可靠的 目标引发行为，结果巩固行为]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDD分层架构规范]]></title>
    <url>%2F2021%2F07%2F05%2FDDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[分层架构图 简述 Controller层：接口层，负责对前端展示的路由和适配；如果需要的话，消费事件和发送消息通知等也可以放在这里； Application层：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理 Domain层：领域是应用的核心，主要是封装了核心业务逻辑，通过领域服务（Domain Service）、领域对象（Entity）的方法对App层提供业务实体和业务逻辑计算； Infrastructure层：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等； 分层说明 APP层采用CQE模型，查询和命令分离 AppService调用实体和IRepo进行编排实现简单业务，通过调用DomainService实现复杂业务场景 AppService和DomainService均为无状态服务 App只允许调用仓储以及实体自带方法，不允许写任何方法，避免出现AppService过大的情况 DomainService封装所有跨实体的业务逻辑 为避免出现AppService之间或者Domainservice之间相互调用，抽取出两者公共部分为一个Helper 聚合根和实体 按聚合根分包，和包名一样的实体为聚合根 可以识别的聚合根就写成聚合根，否则做成实体 聚合根的一致性由自己保障 跨实体的操作放到领域服务中 领域对象实体为充血模型，为一般业务对象，具备业务属性和业务行为 实体都有自己的唯一标识通常 实体可以不和表一一对应，通常操作单个表，可以操作多表 领域服务 某个操作过程或转换过程不是实体的职责时，我们便应该将该操作放在一个单独的接口中，即领域服务。 用于实现某个领域的任务，不适合放在实体对象上时，就放在领域服务上 放在实体的静态方法上有悖DDD 避免在实体中调用资源库，数据通过AppService调用Repo传入 如果有复杂逻辑，其中间的状态依赖前面步骤结果查询数据库作为后续逻辑的输入，通过把Repo传入到Domainservice的方式达到无状态效果 传输对象 DTO：接受Controller层发来的请求，返回结果 Entity ：将DTO转换为要操作的领域层对象 无状态 一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务本身不存储任何信息 有状态服务（stateful service）则相反，它会在自身保存一些数据，先后的请求是有关联的 无状态服务的优势在于可以很方便地水平伸缩]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司战略构建]]></title>
    <url>%2F2021%2F06%2F26%2F%E6%88%98%E7%95%A5%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[整体逻辑 给什么样的客户群，解决什么样的痛点/诉求，投放什么样的产品组合 SAAS模式：订阅+可复制，核心是产品解决客户痛点达到订阅效果 递进逻辑：初始纵向(客户)切分后面横向(产品)，先收割容易的越往后越难，找到破局点需要解决关键的客户问题，构建壁垒看市场 待补充看客户 客户群划分：遵守MECE原则，综合考虑数量、消费力、意愿、净值、消费频次、年龄等维度。 痛点/诉求分析：针对客户群的痛点和诉求进行分析，并进行层次化解析，区分基础诉求、高阶诉求、特殊需求。 小结：客户的群体特性简述，产品和服务的增长可能性在哪里。看竞品 选择竞品：客户群中排在前部的品牌，从市场占有率、行业认可、产品体验等维度选择 竞品对比：分析每个竞品的核心优劣势，三点为佳 小结：竞品优势和劣势总结看自己 优劣势分析：基于行业地位、市场进入先后、组织能力、品牌、客户资源和渠道、解决方案能力、研发能力等角度 策略：如何发挥优势，克服劣势，构建产品，打开市场，增强品牌。。。SWOT分析 基于三看，进行SWOT分析，总结SO/WO/WT/ST策略客户群选择 基于SWOT分析来进行客户群选择和聚焦(找到三个点)，包含对聚焦的细分客户进行产品组合投放(分层)产品矩阵 产品组合策略：对客户群的诉求解决进行产品组合细分 差异化价值分析：对每个产品/模块进行价值分析，凸显产品价值，解决为什么是你的问题。营销策略 对前线伙伴(区域)，做到真正赋能、解决问题并合力前行，让前线从要我做到我要做 对不同市场，分析客户特征，制定市场策略、经营策略和组织策略制定战略屋 划分四个维度：经营目标、主要战场及核心策略、关键战役和组织支撑；逻辑为层层往上支撑。 经营目标： 初创和小型的企业 -&gt; 活下去+构建产品+商业壁垒 成熟企业：市场规模扩大，数字化(利润/客户数等) 主要战场及策略：在这些战场打赢了可以支撑经营目标。 关键战役：通过关键战役来获得整体战场的胜利。 组织支撑：对不同的战场给与什么样的团队资源，采取什么策略。业务蓝图 待补充推导OKR 待补充 问题合集 用什么“产品组合”？ 打什么“目标客户”？ 解决啥“核心问题”？ 有什么“差异竞争” 问题列表1 是认知错误，还是策略错误，还是执行错误？ 某些客户可以作为门票，这张门票很重要,怎么设计好它？ 我们到底选择什么客户、打什么痛点，提供什么产品和服务？ 把问题打开来看，扎进去看! 已经到了这个体量，未来到底何以增长? 历史问题怎么解决？？不要逃避！ 要回答为什么是你，而不是其他人! 尝试A A不行尝试B B也不行，请问我们的洞察是什么? 一定要有客户成功视角：续签率、续费率，看数据！ 问题列表2 没有绝对的优势或劣势，怎么转化为胜势 不要丢掉你们自己，不要把战略屋当填空题 那90%的精力做什么？怎么做？ 拼两件事情：成本结构、运营能力 区域视角，客户成功视角，多视角看战略 花更多时间思考产品本身 越往下越难割，越需要靠产品 如何后发制胜? 每个阶段的战略选择不一样，从0到1、从1到10的阶段，先聚焦打透]]></content>
      <categories>
        <category>战略</category>
      </categories>
      <tags>
        <tag>战略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COLA框架的架构和调用流程]]></title>
    <url>%2F2021%2F02%2F05%2FCOLA%2F</url>
    <content type="text"><![CDATA[架构图四层结构 适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B/S系统而言，adapter就相当于MVC中的controller； 应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层； 领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次； 基础实施层（Infrastructure Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。 组件说明 gateway是为了防腐 Infra层起数据屏蔽作用，如果提供的接口不变，数据层的改动都可以直接在Infra里面完成 第三方服务的调用在Infra层 为了易于理解可以把Adapter改为Controller 调用关系 APP —> Infra, 为了可以直接CRUD，同时也是为什么Infra 可以直接依赖Client包 APP —> gateway, 为了解耦/防腐/数据聚合 APP —> domain service —> gateway —> 存储/缓存/外部服务, 为了实现复杂领域业务灵活使用，覆盖不同的场景 调用过程及对象使用 Client 定义如下对象 VO(View Object)，Adapter层使用 Command，APP层使用，包含Qry、Add/Update/Delete DomainEvent，Infra层发布领域事件使用 ServiceI，APP层实现该服务对外提供应用API Adapter层 接收Command或者参数列表传递给ServiceI 返回Response+VO给前端 APP层 ServiceImpl接收Command 直接/间接传给Mapper 转换成Entity，传给gateway或者domainservice返回Response+VO给Adapter层 Domain — 不依赖其他任何层 定义领域对象Entity Entity作为gateway的参数或返回 Entity作为domain service的参数或返回 Infa 调用数据库直接用Mybatis的Mapper，返回DO 调用第三方服务封装DO和Mapper，返回DO gatewayImpl通过mapper聚合来提供上层数据接口，返回Entity DomainEvent的发布]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK搭建]]></title>
    <url>%2F2020%2F12%2F17%2FELK%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[简介 ELK是elasticsearch、logstash、kibana软件的集合，对外是作为一个日志管理系统的开源方案，它可以从任何来源、任何格式进行日志搜索、分析与可视化展示。基本组成软件： elasticsearch：一个开源分布式搜索引擎，提供收集、分析、存储数据三大功能。 kibana：一个基于web的图形界面，用于搜索、分析和可视化存储在elasticsearch中的日志数据。 logstash：一个服务端的数据处理管道，可以从多个源中提取数据，对其进行转换，然后将其存储到Elasticsearch中。简单来说就是日志的收集、分析、过滤工具。 搭建步骤使用版本是7.9.3，部署前我们可以先提前从官网上下载下面4个安装包：elasticsearch-7.9.3-linux-x86_64.tar.gzkibana-7.9.3-linux-x86_64.tar.gzlogstash-7.9.3.tar.gz 这4个组件可以部署在不同的机器上，只要机器之间是端口开放即可本文档中elasticsearch、logstash、kibana部署在一台机器，filebeat部署在有业务服务的机器上。 创建用户和解压文件 groupadd elk useradd elk -g elk 解压文件： tar -zxvf elasticsearch-7.9.3-linux-x86_64.tar.gz -C /home/elk tar -zxvf kibana-7.9.3-linux-x86_64.tar.gz -C /home/elk tar -zxvf logstash-7.9.3.tar.gz -C /home/elk cd /home/elk mv kibana-7.9.3-linux-x86_64 kibana-7.9.3 chown -R elk:elk /home/elk/elasticsearch-7.9.3 chown -R elk:elk /home/elk/kibana-7.9.3 chown -R elk:elk /home/elk/logstash-7.9.3 部署elasticsearch 切换到elk用户su - elasticsearch cd /home/elk/ 修改elasticsearch.yml cd /home/elk/elasticsearch-7.9.3/config vi elasticsearch.yml 在文件末尾增加以下内容 # 集群初始主节点 cluster.name: &quot;es-cluster&quot; network.host: 0.0.0.0 node.name: &quot;node-1&quot; # discovery type discovery.type: single-node #discovery.seed_hosts: [&quot;127.0.0.1&quot;, &quot;[::1]&quot;] # 设置允许所有ip可以连接该elasticsearch network.host: 0.0.0.0 # 开启监听的端口为9200 http.port: 9200 # 增加新的参数，为了让elasticsearch-head插件可以访问es http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; # 启用密码 xpack.security.enabled: true # 使用默认密码 xpack.security.authc.accept_default_password: true xpack.security.transport.ssl.enabled: true 如果需要外置存储和日志，需要修改path.data和path.logs path.data: /nfsc/cnas_csp_pase_hrx_id010797_vol1003_dev/elasticsearch path.logs: /nfsc/cnas_csp_pase_hrx_id010797_vol1003_dev/elasticsearch_logs 修改Elasticsearch占用内存cd /home/elk/elasticsearch-7.9.3/config vi jvm.options 修改JVM参数 ：-Xms16g -Xmx16g 启动es的时候有可能会报类似的下面的错误【max virtual memory areas vm.max_map_count [65530] is too low】，所以我们可以通过下面的方法去处理：vi /etc/sysctl.conf 文件末尾添加一行vm.max_map_count=655360 保存之后执行下面的命令加载参数sysctl -p 启动Elasticsearch 切换用户，进入bin目录启动：cd /home/elk/elasticsearch-7.9.3/bin ./elasticsearch -d 为内置账号添加密码# interactive：给用户一一设置密码 # auto：自动生成密码 cd /home/elk/elasticsearch-7.9.3/bin/ ./elasticsearch-setup-passwords interactive 验证是否启动成功 # curl -XGET -u elastic &apos;localhost:9200&apos; { &quot;name&quot; : &quot;node-1&quot;, &quot;cluster_name&quot; : &quot;es-cluster&quot;, &quot;cluster_uuid&quot; : &quot;8eGk8_ohRbWl8ZcNSPsFDQ&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.9.3&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;c4138e51121ef06a6404866cddc601906fe5c868&quot;, &quot;build_date&quot; : &quot;2020-10-16T10:36:16.141335Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.6.2&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } 部署kibana 修改配置文件，文件位置在/home/elk/kibana-7.9.3/config目录下 su - elasticsearch cd /home/elk/kibana-7.9.3/config vi kibana.yml 添加es的配置，由于是都在同一台机器所以用localhost，如果是不同机器，就换成对应的ip即可 # kibana端口 server.port: 5601 # 允许所有ip访问 server.host: &quot;0.0.0.0&quot; # elasticsearch所在的ip及监听的地址 elasticsearch.hosts: [&quot;http://localhost:9200&quot;] elasticsearch.username: &quot;kibana_system&quot; elasticsearch.password: &quot;kibana_system&quot; # kibana默认创建的索引 kibana.index: &quot;.kibana&quot; # 字符编码 i18n.locale: &quot;zh-CN&quot; # elasticsearch加密所需配置 xpack.reporting.encryptionKey: &quot;a_random_string&quot; xpack.security.encryptionKey: &quot;something_at_least_32_characters&quot; 启动kibanacd /home/elk/kibana-7.9.3/bin ./kibana &amp; 访问kibana http://IP:5601/ 部署Logstash 修改Logstash的YML配置文件 cd /home/elk/logstash-7.9.3/config/ vim logstash.yml 修改以下内容 # 配置自动刷新 config.reload.automatic: true config.reload.interval: 20s # 配置可任意地址都可访问 http.host: 0.0.0.0 http.port: 9600 # 配置es的访问密码 xpack.monitoring.enabled: true xpack.monitoring.elasticsearch.username: logstash_system xpack.monitoring.elasticsearch.password: logstash_system xpack.monitoring.elasticsearch.hosts: [&quot;http://localhsot:9200&quot;] 修改 pipelines配置文件- pipeline.id: gmp-logs queue.type: persisted path.config: &quot;/home/elk/logstash-7.9.3/conf.d/*.config&quot; 创建日志的config文件 touch /home/elk/logstash-7.9.3/conf.d/logstash-beats.conf 写入文件内容 input { beats { port =&gt; 5044 } } filter { grok { match =&gt; [ &quot;message&quot;, &quot;%{TIMESTAMP_ISO8601:timestamp_string}%{SPACE}%{GREEDYDATA:line}&quot; ] } date { match =&gt; [&quot;timestamp_string&quot;, &quot;ISO8601&quot;] } mutate { remove_field =&gt; [message, timestamp_string] } } output { elasticsearch { hosts =&gt; [&quot;http://localhost:9200&quot;] user =&gt; elastic password =&gt; &quot;elastic&quot; } stdout { codec =&gt; rubydebug } } 启动Logstash(root用户)cd /home/elk/logstash-7.9.3/bin sh logstash -f ../conf.d/logstash-beats.conf &amp;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单时间管理]]></title>
    <url>%2F2020%2F10%2F10%2F%E7%AE%80%E5%8D%95%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[时间管理目标感 给每件事情设定deadline 给长期的事情设置周期循环事项 时间块 30分钟刻度划分 一般管理人员的时间快划分可以到30分钟或者1小时 半天刻度划分 研发人员会按照半天来划分时间，涉及到写代码、用例、测试计划、编译、部署等具体工作，需要时间来思考及实现，所以有效的时间块划分是半天或者一天。 固化日程固化日程即养成好的习惯，使得时间利用率高，事情处理效率高。有些固定模板可套用，如： 上班后/下班前处理今日事项和明日规划 早会及总结 上午做需求评审，下午写代码，晚上做分享 个人日程示例： 123456789108.45-9.00：查看日程，规划今天事务9.15-9.30： 早会9.30-9.45：整理项目的进度和风险10.00-11.00： 检视930版本需求11.00-11.50： XX技术方案/需求评审会议———————————————————1.30-3.00：写代码3.15-6.00： 接口设计7.00-8.45： 小组分享8.45-9.00： 今日事项总结，明日事项规划 工具和方法论工具：microsoft todo、滴答清单、calendar方法论：GTD(Get things done)]]></content>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题2]]></title>
    <url>%2F2020%2F08%2F24%2F%E6%97%A0%E9%A2%982%2F</url>
    <content type="text"><![CDATA[我与地坛但是太阳，他每时每刻都是夕阳也都是旭日。当他熄灭着走下山去收尽苍凉残照之际，正是他在另一面燃烧着爬上山巅布散烈烈朝辉之时。那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。当然，那不是我。但是，那不是我吗？宇宙以其不息的欲望将一个歌舞炼为永恒。这欲望有怎样一个人间的姓名，大可忽略不计。]]></content>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2020%2F02%2F06%2F%E6%97%A0%E9%A2%981%2F</url>
    <content type="text"><![CDATA[在那些没有信心靠自己努力奋斗找到前途的人们当中，你很难找到独立的精神和坚强的个性。Independence of mind or strength of character are rarely found among those who cannot be confident that they will make their way by their own effort. —— 哈耶克《通往奴役之路》]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装k8s for docker desktop]]></title>
    <url>%2F2020%2F01%2F27%2FMac%E5%AE%89%E8%A3%85k8s%20for%20docker%20desktop%2F</url>
    <content type="text"><![CDATA[安装docker desktop for mac 下载 Docker CE最新版本 地址： https://store.docker.com/search?type=edition&amp;offering=community 版本信息： 配置镜像加速 阿里云镜像服务 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 中科大镜像加速地址 https://docker.mirrors.ustc.edu.cn mac配置： 开启kubernetes 下载离线镜像 123git clone https://github.com/AliyunContainerService/k8s-for-docker-desktopcd k8s-for-docker-desktop./load_images.sh 安装并启动kubernetes 配置 CPU 和 内存资源 开启 Kubernetes 安装k8s dashboard应用 部署dashboard 1kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 或者 1kubectl create -f kubernetes-dashboard.yaml 开启API Server访问代理 1kubectl proxy 访问Kubernetes dashboard URL： http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default 配置控制台访问令牌 登录dashboard时 选择令牌，输入下文控制台输出的内容 123TOKEN=$(kubectl -n kube-system describe secret default| awk '$1=="token:"&#123;print $2&#125;')kubectl config set-credentials docker-for-desktop --token="$&#123;TOKEN&#125;"echo $TOKEN 选择 Kubeconfig 文件 路径如下：$HOME/.kube/config 安装过程中的问题kubernets is starting k8s 一直是开始状态而不是running状态，查看官方的issue列表中找到如下解决方案 1. 使用如下命令查看日志 12$ pred='process matches ".*(ocker|vpnkit).*" || (process in &#123;"taskgated-helper", "launchservicesd", "kernel"&#125; &amp;&amp; eventMessage contains[c] "docker")'$ /usr/bin/log stream --style syslog --level=debug --color=always --predicate "$pred" 2. 卸载docker panel 3. 删除 .kube file 1rm -rf ~/.kube 4. 编辑/etc/hosts. (第一行包含**docker-for-desktop**) 编辑后如下: 123127.0.0.1 localhost docker-for-desktop255.255.255.255 broadcasthost::1 localhost 5. 重新安装kubernets 问题参考链接 https://github.com/docker/for-mac/issues https://github.com/docker/for-mac/issues/3327]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>kubernets</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7和8下搭建shadowsocks-libev]]></title>
    <url>%2F2019%2F10%2F12%2FCentOS%207%E5%92%8C8%E6%90%AD%E5%BB%BASS%2F</url>
    <content type="text"><![CDATA[CentOS 7和8下搭建shadowsocks-libev安装shadowsocks-libev12cd /etc/yum.repos.d/curl -O https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo 源路径在CentOS7和8下不同，如下： 1234# CentOS7URL=https://copr.fedorainfracloud.org/coprs/outman/shadowsocks-libev/repo/epel-7/outman-shadowsocks-libev-epel-7.repo# CentOS8URL=https://copr.fedorainfracloud.org/coprs/outman/shadowsocks-libev/repo/epel-8/outman-shadowsocks-libev-epel-8.repo 安装 1234yum updateyum install -y epel-releaseyum install -y libsodium shadowsocks-libev simple-obfsyum install -y shadowsocks-libev 配置ss打开/etc/shadowsocks-libev/config.json，如果不存在该文件则需要新建。 配置对应的参数： server：当前自己的服务器的地址比如：0.0.0.0 server_port：ss服务的端口一般要大于1024，小于65536,可以随意取值，只要不和其他端口冲突即可比如：21500 password：ss客户端使用ss时要使用的密码最好设置一个复杂但安全的密码，例如：Ci20s5a6y96F method：加密方式以前常见的方式是：aes-256-cfb最新更加复杂但更安全的是：chacha20-ietf-poly1305注意: 需要ss客户端要支持该加密方式才能正常使用ss服务 timeout：超时时间，单位：秒比如：300 mode：ss服务的模式比如：tcp_and_udp，即支持tcp也支持udp 示例： 12345678&#123; "server": "0.0.0.0", "server_port": 21500, "password": "Ci20s5a6y96F", "method": "chacha20-ietf-poly1305", "timeout": 300, "mode": "tcp_and_udp"&#125; 防火墙上打开端口12firewall-cmd --permanent --add-port=xxxx/tcpfirewall-cmd --reload 启动shadowsocks-libev启动：1systemctl restart shadowsocks-libev 开机启动：1systemctl enable shadowsocks-libev 生成复杂但安全的密码http://ucdok.com/project/generate_password.html Debug查看服务状态1systemctl status shadowsocks-libev 查看日志1journalctl -u shadowsocks-libev 查看端口是否启动1netstat -tnlp | grep xxxx 实现shadowsocks-libev多用户新建另外一个配置文件，比如：1/etc/shadowsocks-libev/config2.json 内容和之前一致，只是端口号server_port和密码password改了一下即可：12345678&#123; "server": "0.0.0.0", "server_port": 21501, "password": "passowrd2", "method": "aes-256-cfb", "timeout": 300, "mode": "tcp_and_udp"&#125; 注意: 端口号不要和系统中其他服务的端口号冲突了。 另外再去用：1setsid ss-server -c /etc/shadowsocks-libev/config2.json -u 启用新端口对应的ss服务。]]></content>
      <categories>
        <category>firewall</category>
      </categories>
      <tags>
        <tag>墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL面试题]]></title>
    <url>%2F2019%2F09%2F06%2FMysql%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[MySQL面试题基础知识 常用的MySQL引擎有哪些？ MyISAM和InnoDB区别 MySQL事务，解释ACID SQL标准定义的四个隔离级别 CHAR和VARCHAR的区别？ FLOAT和DOUBLE的区别是什么？ 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ BLOB和TEXT有什么区别？ Heap表是什么？ DROP、DELETE、TRUNCATE的区别 MySQL里记录货币用什么字段类型好 通用SQL函数有哪些？ NOW（）和CURRENT_DATE（）有什么区别？ MySQL查询是否区分大小写？ 主键 超键 候选键 外键 视图的作用，视图的优缺点，视图可以更改么？ MySQL有关权限的表都有哪几个？ MySQL数据表在什么情况下容易损坏？ 对Explain参数及重要参数的理解？ MySQL binlog的几种日志录入格式以及区别 索引、锁 MySQL索引的目的和原理 MySQL索引的数据结构和算法原理 索引对性能的影响 索引的使用场景 索引的创建原则 什么是索引合并？ 什么是覆盖索引？ MySQL索引的注意事项 列举创建索引但是无法命中索引的情况 为什么使用B+Tree B-Tree和B+Tree的区别 最左前缀原理 什么是聚集索引和非聚集索引 可以使用多少列创建索引？ MySQL中有哪几种锁？ 什么是乐观锁和悲观锁 乐观锁和悲观锁的区别及使用场景 乐观锁常见的两种实现方式 乐观锁的缺点 什么是MVCC MySQL的innodb引擎是如何实现MVCC的 MySQL中InnoDB引擎的行锁是怎么实现的？为什么是这样子的？ 调优诊断 对SQL语句优化有哪些方法？ MySQL如何优化DISTINCT？ 锁的优化策略 MySQL数据库CPU飙升到500%的话他怎么处理？ MySQL数据库服务器性能分析的方法命令有哪些? 数据库结构优化的建议有哪些 Schema设计对系统性能有什么影响？ 解答题 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把MySQL重启，再insert一条记录，这条记录的ID是18还是15 ？ 如何在MySQL种获取当前日期？ 如何查询第n高的工资？ 有A(id,sex,par,c1,c2),B(id,age,c1,c2)两张表，其中A.id与B.id关联，现在要求写出一条SQL语句，将B中age&gt;50的记录的c1,c2更新到A表中同一记录中的c1,c2字段中 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录 1000w条数据，使用limit offset 分页时，为什么越往后翻越慢？如何解决？ 运维安全 SQL注入漏洞产生的原因？如何防止？ 关于SQL语句应该考虑哪些安全性？ 简述数据库的读写分离？ 简述数据库分库分表？（水平、垂直） MySQL的复制原理以及流程 Mysql热备方案和原理]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题]]></title>
    <url>%2F2019%2F08%2F27%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java面试题Java基础面试知识点 java中==和equals和hashCode的区别 int、char、long各占多少字节数 int与integer的区别 解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling） String、StringBuffer、StringBuilder区别 什么是内部类？内部类的作用 抽象类和接口区别 抽象类的意义 抽象类与接口的应用场景 抽象类是否可以没有方法和属性？ 接口的意义 泛型中extends和super的区别 父类的静态方法能否被子类重写 进程和线程的区别 final，finally，finalize的区别 序列化的方式 transient关键字的作用 Serializable 和Parcelable 的区别 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ 静态内部类的设计意图 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用 string 转换成 integer的方式及原理 反射是如何实现的，在哪些场景用到反射 反射中 Class.forName 和 ClassLoader 区别 反射创建类实例的三种方式是什么 如何通过反射调用对象的方法，获取和设置对象私有字段的值 反射机制的优缺点 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配 什么是懒加载（Lazy Loading） 什么是尾递归，为什么需要尾递归 Java高级面试题 讲一下常见编码方式？ utf-8编码中的中文占几个字节；int型几个字节？ 静态代理和动态代理的区别，什么场景使用？ Java的异常体系 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？ 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里 可以在 hashcode() 中使用随机数字吗？ Java中实现多态的机制是什么？ 如何将一个Java对象序列化到文件里？ 说说你对Java反射的理解 Java动态代理的实现方式及原理 说说你对Java注解的理解 说说你对依赖注入的理解 说一下泛型原理，并举例说明 Java中String的了解 String为什么要设计成不可变的？ java中的四种引用的区别以及使用场景 强引用置为null，会不会被回收？ Java数据结构 常用数据结构有哪些 并发集合了解哪些？ 列举java的集合以及集合之间的继承关系 集合类以及集合框架 容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections） List、Set、Map的区别 List和Map的实现方式以及存储方式 ArrayList和LinkedList的区别，以及应用场景 数组和链表的区别 HashMap的实现原理及源码理解 HashMap如何put数据（从HashMap源码角度讲解） HashMap的遍历方式及效率 怎么手写实现一个HashMap HashTable实现原理 TreeMap具体实现 ConcurrentHashMap的实现原理 ArrayMap和HashMap的对比 HashMap与HashSet的区别 HashMap 、HashTable、ConcurrentHashMap 的区别 HashMap、LinkedMap、TreeMap的区别 如何决定选用HashMap还是TreeMap HashSet与HashMap怎么判断集合元素重复 集合Set实现Hash怎么防止碰撞 WeakHashMap 是怎么工作的？ 二叉树的深度优先遍历和广度优先遍历的具体实现 堆的结构 堆和树的区别 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？ 什么是深拷贝和浅拷贝 讲一下对树、B+树的理解 讲一下对图的理解 判断单链表成环与否？ Java线程、多线程、线程池、锁 开启线程的三种方式？ 线程和进程的区别？ 为什么要有线程，而不是仅仅用进程？ run()和start()方法区别 如何控制某个方法允许并发访问线程的个数？ 在Java中wait和seelp方法的不同； 谈谈wait/notify关键字的理解 什么导致线程阻塞？ 线程如何关闭？ 讲一下java中的同步的方法 数据一致性如何保证？ 如何保证线程安全？ 如何实现线程同步？ 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？ 线程间操作List Java中对象的生命周期 Synchronized用法和原理 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解 static synchronized 方法的多线程访问和作用 同一个类里面两个synchronized方法，两个线程同时访问的问题 volatile的原理 谈谈volatile关键字的用法和作用以及场景 谈谈NIO的理解 synchronized 和volatile 关键字的区别 synchronized与Lock的区别 ReentrantLock 、synchronized和volatile比较 ReentrantLock的内部实现 lock原理 死锁的四个必要条件？ 怎么避免死锁？ 对象锁和类锁是否会互相影响？ 什么是线程池，如何使用? Java的并发、多线程、线程模型 ThreadLocal 用途是什么，原理是什么，用的时候要注意什么 ThreadPool用法与优势，线程池队列已满时会发会生什么 线程池的实现策略 线程池的关闭方式有几种，各自的区别是什么 线程池中submit() 和 execute()方法有什么区别？ 谈谈对多线程的理解 多线程有什么要注意的问题？ Java中用到的线程调度算法是什么 什么是多线程中的上下文切换，避免上下文切换的方案(无锁编程/CAS/合理的创建线程) JAVA线程间的状态转换 你对线程优先级的理解是什么 Java多线程的三大核心是什么？(原子性、可见性、顺序性) 什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing) 谈谈你对多线程同步机制的理解？ 什么是多线程环境下的伪共享（false sharing） 如何保证多线程读写文件的安全？ 多线程断点续传原理 断点续传的实现 并发编程 谈谈你对并发编程的理解并举例说明 Java 中锁机制：synchronized、Lock、Condition 深入分析ConcurrentHashMap BlockingQueue是什么 简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处 ArrayBlockingQueue, CountDownLatch的用法 CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么 Semaphore的用法 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁 什么时候应该使用可重入锁 简述锁的等级方法锁、对象锁、类锁 Java中活锁和死锁有什么区别？ 什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁 死锁与活锁的区别，死锁与饥饿的区别 怎么检测一个线程是否拥有锁 如何实现分布式锁 有哪些无锁数据结构，他们实现的原理是什么 读写锁可以用于什么应用场景 JVM Java 内存模型，1.8和1.9的区别 Java类加载机制 Java 堆内存溢出分析 MetaSpace (元数据) 内存溢出一般是什么原因 垃圾回收算法有哪些 哪些情况下的对象会被垃圾回收机制处理掉？ 深入理解java内存模型–参考InfoQ系列文章 架构设计和设计模式 聊了下曾经参与设计的服务器架构 为什么要进行系统拆分？如何进行系统拆分？拆分后不用 Dubbo 可以吗？ BS与CS的联系与区别 什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别 什么是领域驱动开发（Domain Driven Development） 请简要讲一下你对测试驱动开发（TDD）的认识 微服务（MicroServices）与单体应用（Monolithic Applications）之间的区别在哪里 REST、RPC、RMI有什么区别 MVC MVP MVVM原理和区别 你所知道的设计模式有哪些？ 项目中常用的设计模式 手写生产者/消费者模式 写一个你认为最好的单例模式 写出观察者模式的代码 适配器模式，装饰者模式，外观模式的异同？ 用到的一些开源框架，介绍一个看过源码的，内部实现过程。 从0设计一个小程序项目整体架构，如何去做？ 说一款你认为当前比较火的应用并设计(比如：电商、直播APP，P2P金融，小视频等) 谈谈对java状态机理解 对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？ 你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些 实现一个Json解析器(可以通过正则提高速度) 什么样的项目不适合用框架 新浪微博是如何实现把微博推给订阅者 说出数据连接池的工作机制是什么 怎么提升系统的QPS和吞吐量 你有了解过存在哪些反模式（Anti-Patterns）吗 你用过的网站前端优化的技术有哪些 如何搭建一个高可用系统 如何启动时不需输入用户名与密码 如何在基于Java的Web项目中实现文件上传和下载 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。 如何实现负载均衡，有哪些算法可以实现 如何设计一个购物车？想想淘宝的购物车如何实现的 如何设计一套高并发支付方案，架构如何设计 如何设计建立和保持 100w 的长连接 如何避免浏览器缓存。 如何限流？在工作中是怎么做的？说一下具体的实现？ 如何进行熔断？ 熔断框架都有哪些？具体实现原理知道吗？ 如何进行降级？ 如何防止缓存雪崩 如果有人恶意创建非法连接，怎么解决 什么是微服务？微服务之间是如何独立通讯的？ Spring Cloud 和 Dubbo 有哪些区别？ Spring Boot 和 Spring Cloud，谈谈你对它们的理解？ 什么是服务熔断？什么是服务降级？ 微服务的优缺点分别是什么？说一下你在项目开发中碰到的坑？ 你所知道的微服务技术栈都有哪些？ Eureka 和 Zookeeper 都可以提供服务注册与发现的功能，它们有什么区别？ 性能优化 遇到过的内存泄漏或栈溢出场景，CPU利用率飙高，应用无响应时怎么解决？ 如何分析Thread dump Java多线程引发的性能问题，怎么解决？ 如何保持应用的稳定性 线上系统突然变得异常缓慢，你如何查找问题 网站性能优化如何优化 SQL优化的常见手段 分布式 CDN实现原理 什么是 Raft和Paxos 算法 什么是 zab 协议 解释什么是 MESI 协议(缓存一致性) 解释CAP、BASE 什么是幂等，如何实现 分布式事务的原理，优缺点，如何使用分布式事务？ 你们如何解决分布式事务问题的？TCC 如果出现网络连不通怎么办？XA 的一致性如何保证？ 分布式ID 生成器的实现方案及优缺点(数据库、本地UUID、本地时间、雪花算法) 分布式锁的实现方式及优缺点 分布式缓存设计需要考虑哪些因素 分布式 Session如何实现 为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？ 如何保证消息队列的高可用？ 如何保证消息不被重复消费？（如何保证消息消费的幂等性） 如何保证消息的可靠性传输？（如何处理消息丢失的问题） 如何保证消息的顺序性？ 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 高并发下，如何做到安全的修改同一行数据 12306网站的订票系统如何实现，如何保证不会票不被超卖 实现分布式环境下的 countDownLatch es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？ es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？ es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？ es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？ 算法 排序算法有哪些？ 最快的排序算法是哪个？ 手写一个冒泡排序 手写快速排序代码 手写一个折半查找 手写堆排序 实现一个电梯模拟器用 随机产生20个不能重复的字符并排序 写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组 写一段代码在遍历 ArrayList 时移除一个元素 快速排序的过程、时间复杂度、空间复杂度 堆排序过程、时间复杂度及空间复杂度 写出你所知道的排序算法及时空复杂度，稳定性 二叉树给出根节点和目标节点，找出从根节点到目标节点的路径 给阿里2万多名员工按年龄排序应该选择哪个算法？ GC算法(各种算法的优缺点以及应用场景) 蚁群算法与蒙特卡洛算法 约瑟芬环游戏 子串包含问题(KMP 算法)写代码实现 一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法 万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射-&gt;hash分组-&gt;多文件读写效率-&gt;磁盘寻址以及应用层面对寻址的优化) 百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。 两个不重复的数组集合中，求共同的元素。 两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？ 一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法 一张Bitmap所占内存以及内存占用的计算 2000万个整数，找出第五十大的数字？ 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？ 求1000以内的水仙花数以及40亿以内的水仙花数 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同 时针走一圈，时针分针重合几次 N*N的方格纸,里面有多少个正方形 x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？ 50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少 如果让你实现一个并发安全的链表，你会怎么做 计算两个日期之间的差距 编程题1. 计算加班费 加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时） 计算1000月薪，加班9小时的加班费 计算2500月薪，加班11小时的加班费 计算1000月薪，加班15小时的加班费 2. 卖东西 一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。 模拟一个进货。红苹果跟青苹果各进200个。 模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。 提示：一个苹果是一个单独的实体。 3. 日期提取 有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08 4. 线程 8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出 wait-notify 写一段代码来解决生产者-消费者问题 5. 数字计算 判断101-200之间有多少个素数，并输出所有素数 用最有效率的方法算出2乘以17等于多少 有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优 2 亿个随机生成的无序整数,找出中间大小的值 10 亿个数字里里面找最小的 10 个 1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 =&gt; 1 + … + 9 + 1 + 0 + 1 + 1 一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程 找出1000以内的所有完数 一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？ 求100－1000内质数的和 求1到100的和的平均数 求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和 算出1到40的质数，放进数组里 显示放组里的数 找出第[5]个数 删除第[9]个数，再显示删除后的第[9]个 有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。 有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数 计算指定数字的阶乘 给定一个包含 N 个整数的数组，找出丢失的整数 一个排好序的数组，找出两数之和为m的所有组合 将一个正整数分解质因数。例如：输入90,打印出90=233*5。 打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方 原地交换两个变量的值 找出4字节整数的中位数 找到整数的平方根 6. 逻辑代码题 FizzBuzz问题 实现斐波那契 写一个死锁 手写生产者/消费者模式 写一个你认为最好的单例模式 写一个观察者模式 手写一个冒泡排序 手写快速排序代码 手写一个折半查找 手写堆排序 手写链表逆序代码 合并有序链表 约瑟芬环游戏 其他问题 在你的职业生涯中，算得上最困难的技术挑战是什么 如果有机会重新设计你们的产品，你会怎么做 最近看什么书，印象最深刻的是什么 你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最大困难是什么以及如何解决的？ 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？ 工作过程中周围同事/同学有哪些值得学习的地方？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫斯问题有时也称为约瑟夫斯置换，是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。 问题有n个人编号，站成一圈：1 2 3 4 … … n-1 n 现在从1开始进行报数，报到k的出列自杀，然后剩下的人继续从1报数（当到达编号为n的人时，下一个报数的从编号为1的人开始进行）：1 2 3 4… k(出列自杀) 1 2 … 直到圈内只剩余m人，求胜利者的编号。例如：当n=6, k=5, m=1时，5,4,6,2,3将会被依次处决，而1将会幸免。 示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.List;public class JosephProblem &#123; /** * 返回活着的人的位置 * * @param total 总人数 * @param magicNum 报数到该数字的人自杀 * @param remain 笑着活下去的人 * @return */ private List getJosephNumbers(int total, int magicNum, int remain) &#123; List&lt;Integer&gt; peopleList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= total; i++) &#123; peopleList.add(i); &#125; List&lt;Integer&gt; diedList = new ArrayList&lt;&gt;(); int index = -1; //当前应该删除的位置 while (true) &#123; index = (index + magicNum) % peopleList.size(); diedList.add(peopleList.get(index)); peopleList.remove(index); //从上一个位置开始计数 index--; //判断是否剩余m个，如果是的话结束 if (peopleList.size() == remain) &#123; System.out.println("共" + total + "人，依次报数，当报到" + magicNum + "的人自杀，" + remain + "个人笑着活下去."); System.out.println("死掉的序号顺序为：" + diedList); System.out.println("笑着活下去序号为：" + peopleList); System.out.println("----------------------------------"); return peopleList; &#125; &#125; &#125; public static void main(String[] args) &#123; JosephProblem test = new JosephProblem(); test.getJosephNumbers(10, 4, 1); test.getJosephNumbers(10, 2, 1); test.getJosephNumbers(10, 3, 1); test.getJosephNumbers(20, 10, 3); test.getJosephNumbers(20, 4, 6); &#125;&#125; 输出结果：1234567891011121314151617181920共10人，依次报数，当报到4的人自杀，1个人笑着活下去.死掉的序号顺序为：[4, 8, 2, 7, 3, 10, 9, 1, 6]笑着活下去序号为：[5]----------------------------------共10人，依次报数，当报到2的人自杀，1个人笑着活下去.死掉的序号顺序为：[2, 4, 6, 8, 10, 3, 7, 1, 9]笑着活下去序号为：[5]----------------------------------共10人，依次报数，当报到3的人自杀，1个人笑着活下去.死掉的序号顺序为：[3, 6, 9, 2, 7, 1, 8, 5, 10]笑着活下去序号为：[4]----------------------------------共20人，依次报数，当报到10的人自杀，3个人笑着活下去.死掉的序号顺序为：[10, 20, 11, 2, 14, 6, 19, 15, 9, 7, 5, 8, 13, 18, 12, 4, 17]笑着活下去序号为：[1, 3, 16]----------------------------------共20人，依次报数，当报到4的人自杀，6个人笑着活下去.死掉的序号顺序为：[4, 8, 12, 16, 20, 5, 10, 15, 1, 7, 14, 2, 11, 19]笑着活下去序号为：[3, 6, 9, 13, 17, 18]----------------------------------]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队规划考核]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%9B%A2%E9%98%9F%E8%A7%84%E5%88%92%E5%8F%8A%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[前言团队需要一些好的机制来保障团队的目标达成，规划、汇报和考核需要做到常规化，下面写的是一些个人实践。 规划和汇报 按季度/月度做规划，建议采用OKR或者OKR+KPI结合的方式来规划目标、拆解关键点以及结果。 按双周迭代方式来进行开发测试，采用敏捷的方式 腾讯TAPD是个不错的工具，经历了几家公司都推行使用，效果不错，关键是免费。 按周进行团队事务管理 每周一 团队协调人让组员规划本周所要做的事情，如有不合理需要沟通解决 每天 组员自行记录工作日志 今天做了什么、明天要做什么、有什么问题和困难 每周末 团队协调人写周报(本周工作内容和下周计划)，主要包含 项目、月/季度目标、关键节点、负责人、当前进度、预期完成时间、问题 按月进行绩效考核 优秀的会有工资浮动 月度考核目前的组织架构参考敏捷团队模型，我们把原有的职能型组织架构做成虚拟组织，采用敏捷团队(包含前后端测试)来推进，更加偏向于业务推进型，原有职能型组织的Leader组成委员会成员 类似与Spotify的分队和协会，具体理念参考Spotify大规模敏捷之路 对团队的评分标准参考下图： 说明如下： 先确定整个大团队月度优秀员工数量 由委员会和总监直接提名少量优秀员工，主要是针对有一些岗位不在团队内部或者在团队中占少数不好参与团队考核，比如助理、设计师、都是人数少的岗位。 确定团队的优秀员工数，按照下面的标准来评测 第一和最末的团队，优秀员工数量加一和减一 标准维度主要如下： 1234项目进度(本月)项目质量(Bug数据)组内制度的制定与落地&amp;外部沟通对公共项目、外部项目、委员会的工作支持 数据依据: 1234月初工作计划表TAPD Bug数据制度落地和实施状况及外部反馈委员会成员的评分 确定团队成员中哪些拿到优秀员工，有两条维度线来打分 Leader打分 委员会打分 得出分数排名，给与优秀员工 委员会标准如下图：]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>规划</tag>
        <tag>考核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPA常见问题]]></title>
    <url>%2F2019%2F06%2F27%2FRPA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[What is RPA? RPA (Robotic Process Automation) is a type of automation where a machine or computer mimics a human’s action in completing rules based tasks. How RPA is different from Test Automation? Both Test Automation and RPA involve “Automation” and offer advantages of reducing manual intervention and delivering quality, but these two or different… RPA – Robotic Process Automation, Automates Business Processes like Data Entry, Queries, Calculations, and Transactions in various organizations. where as Test Automation Automates Software Testing Processes,It automates Functional Testing, Performance Testing, Web Services Testing Etc. of Software Products. Using Blueprism, Automation Anywhere, Uipath etc… tools we can automate Business Automation, and Using Selenium, UFT/QTP, LoadRunner SoapUI etc…Software Tools we can automate software Testing Processes. What type of processes can be automated with RPA? RPA is software-based, it can be used to perform various tasks. These include Maintenance of records, queries, calculations, and transactions. Additionally, any application commonly used by your company can be operated by RPA. Citrix, .NET, HTML, and Java are all technologies commonly supported by RPA. Compatible systems include Mainframe Terminals, SAP, Oracle, Blackline, and many more. RPA can be configured to perform almost any rule-based task. What are the Popular RPA Tools?Popular Robotic Process Automation (RPA) Tools to automate the Business Processes. Blue Prism Blue Prism is the trading name of the Blue Prism Group, a UK multinational software corporation, the term Robotic Process Automation was invented by Blue Prism, that itself proves they are the pioneers in Robotic Process Automation Software Development. Automation Anywhere Automation Anywhere is another top RPA vendors providing powerful and User- friendly robotic process automation tools to automate tasks of any complexity. UiPath UiPath is a Windows desktop Robotic Process Automation (RPA) Software used for automation for various web,desktop,citrix,etc based applications. Other Popular RPA tools are Pega, Nice, and Workfusion etc… How to Select a RPA Tool?By considering several factors we select a RPA Tool for Businness Process Automation, Technology First and foremost is the technology in which RPA tool has been built, like Microsift .NET, IBM Mainframe, Java, web etc. The tool has to be platform independent, considering many of the organizations perform their day to day tasks outside the local desktop using Citrix or Virtual machines etc. So the automation solution should be able to support any application and platform. Interface Next most important feature is the RPA tool’s user interface. A complex user interface will delay the process of implementation and increase the learning curve and adaptability. A more user friendly interface like drag and drop, auto capture, image recognition etc. would be better. Management It is important to know how effectively and easily the robots can be managed, considering these robots are going to be replacing your human workforce. There should be a high level of visibility and control in terms of process monitoring, process change, development, re-use etc. Security Security is one of the most important factor to be considered. How safe are the robots when compared to the humans? After all robots/RPA tools are also a piece of software, so how much more security controls can be implemented, test the code rigidly and lock it up, the better. 6) What are the important Phases of RPA Life Cycle?Phases of RPA Life Cycle: Analysis Life cycle in RPA begins with analysis phase. Business team and RPA Architect work together to identify a business process for RPA development. Bot Development RPA developer(Team) starts working on requirement in their environment possibly a separate development environment. Testing There are two approaches on which testing is being carried out- Some organisations conduct Testing by Separate Testing Team, While other few have a dedicated testing team which perform a dedicated QA like normal SDLC flow. Best Practice is to have a dedicated testing team which perform QA of developed bot. Deployment and Maintenance- After the Development and Testing closure, a bot is ready for deployment and enters maintenance phase. How to implement Robotic Process Automation?There are mainly 6 steps to be followed for a successful RPA implementation. Identify the Automation Opportunities Optimize the Identified Processes Build a Business Case RPA Vendor Selection Pilot RPA Development Ramp up and Continue Building Expertise RPA bots. Explain about RPA Testing?At a broader level RPA testing can be grouped in to 2 categories. First one is testing the business processes automated through RPA and the second one is testing the instructions passed on to Robots to execute user actions. Business Process Testing This is nothing but the conventional testing done for any application. The end to end business process automated by the RPA tool has to be validated here. If we have to test the RPA use case, a scenario would be to test if Robot is able to get the file from server, read the data from application, compare these two data sources, identify any conflicts and send an email notification to respective owner. All combinations of data are to be validate like it is done for any other application. Robots Testing There are multiple aspects when testing Robots. The first one is interpretation of the models by Robots. It is very important that the Robots are able to interpret the instructions given through the models correctly and able to perform actions on the UI accordingly. This need not be tested regularly but when the model is designed/modified or before a Robot is put into use. What are different RPA Jobs?Robotics Process Automation jobs can be broadly classify into 3 major categories. RPA Developers/Architects Robotic Process Automation Consultants RPA Leads/Managers What are advantages of Robotic Process Automation? Faster As bots are handling the execution here, a larger amount of work can be done in a relatively much shorter period. A faster delivery, coupled with accuracy. Cost Effective It has been estimated that using robotics cuts operational costs, Robots can operate 24/7 and take no vacation, when compared to humans. Consistency Robotics is a safe, non-invasive technology that doesn’t interfere with the inherent systems and provides perfect consistency in performing the activities across the board, each time and every time. Accuracy &amp; Quality RPA offers improved services to processes that have a high probability of human error, thereby increasing accuracy. Robots are reliable, and consistent and do not whine when expected to work tirelessly. Increased Customer Satisfaction Delivering better quality of work with high accuracy and improved customer/client interaction leads to increased customer and client satisfaction. Improved Analytics Having access to error free, accurate data from various sources would improve the quality of analytics in the process. What are Limitations of Robotic Process Automation? RPA certainly boosts company efficiency by automating repetitive human effort, but there are limitations to the types of work that it can be applied to – specifically ones that require judgement. RPA cannot read any data that is non-electronic with unstructured inputs. companies need to be aware of diverse inputs coming from multiple sources. RPA is not a cognitive computing solution. It cannot learn from experience and therefore has a ‘shelf life’. As processes evolve Applying RPA to a broken and inefficient process will not fix it. RPA is not a Business Process Management solution and does not bring an end-to-end process view.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Libra环境搭建和第一笔交易]]></title>
    <url>%2F2019%2F06%2F22%2FLibra%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AC%94%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[环境准备 Linux或者Mac OS系统，本次测试使用CentOS 7.5 稳定的网络环境，并且连接到互联网 提前安装Git 如果是MacOS，需要提前安装Homebrew yum 或者 apt-get命令 踩的坑： 安装包：yum install -y git gcc gcc-c++ ncurses-devel bison CMake版本低(2.8)导致编译错误，升级到3.14.4解决 安装Libra Core克隆代码库1git clone https://github.com/libra/libra.git 运行安装脚本，安装依赖12cd libra./scripts/dev_setup.sh 该初始化脚本执行了如下动作： 安装rustup – rustup是Rust官方的跨平台安装工具器, Libra Core使用Rust来实现 安装rust-toolchain的必要版本 安装CMake – 管理编译和构建 安装protoc – protocol buffers的编译器 安装Go – 为了构建protocol buffers使用 构建Libra CLI客户端并连接到测试网络执行客户端脚本来连接到测试网络上的节点，时间较长，需耐心等待。。。1./scripts/cli/start_cli_testnet.sh 一旦连接到网络会看到如下输出信息：123456789101112131415161718192021Connected to validator at: ac.testnet.libra.org:8000usage: &lt;command&gt; &lt;args&gt;Use the following commands:account | atrueAccount operationsquery | qtrueQuery operationstransfer | transferb | t | tbtrue&lt;sender_account_address&gt;|&lt;sender_account_ref_id&gt; &lt;receiver_account_address&gt;|&lt;receiver_account_ref_id&gt; &lt;number_of_coins&gt; [gas_unit_price_in_micro_libras (default=0)] [max_gas_amount_in_micro_libras (default 10000)] Suffix 'b' is for blocking.trueTransfer coins (in libra) from account to another.help | htruePrints this helpquit | q!trueExit this clientPlease, input commands:libra% 使用help可以看到命令列表，可以执行的命令如下： account – 账户相关操作 create – 创建账户 list – 查看所有账户列表 mint – 增加libra币 write &lt;file_path&gt; – 保存libra钱包到磁盘 recover &lt;file_path&gt; – 从磁盘恢复libra钱包 query – 查询操作 balance &lt;account_ref_id&gt;|&lt;account_address&gt; – 查询账户余额 sequence – 获得账户当前sequence number account_state – 获取账户最近状态 txn_acc_seq – 通过账号或者sequence number获取已提交的交易 txn_range – 通过version范围获取已提交的交易 event – 通过账号或者事件类型来获取事件列表 transfer – 转账操作 transfer – 从一个账户转libra币到另外一个账户 transferb – transfer的阻塞式操作 quit – 退出连接 创建账户创建账户A123libra% account create&gt;&gt; Creating/retrieving next account from walletCreated/retrieved account #0 address 1b7f0e3123d52cd4b80d451da785a1db96a5ec6a9cdcd84d5d344341b8e77158 创建账户B123libra% account create&gt;&gt; Creating/retrieving next account from walletCreated/retrieved account #1 address fc5fecde4dee37102a49085725f5d4491d9e9cda00afba078988eba0696c4691 列出本地所有账户信息：123libra% account listUser account index: 0, address: 1b7f0e3123d52cd4b80d451da785a1db96a5ec6a9cdcd84d5d344341b8e77158, sequence number: 0, status: LocalUser account index: 1, address: fc5fecde4dee37102a49085725f5d4491d9e9cda00afba078988eba0696c4691, sequence number: 0, status: Local A和B只是为了方便书面称谓，Libra目前不支持给账户命名，但如上A对应编号为0的账户，B对应编号为1的账户。地址后面的 sequence 指的是这个账户主动发起转账的次数，目前两个账户都还没有发起过转账，所以都是 0。 给账户铸币给A账户铸币1000123libra% account mint 0 1000&gt;&gt; Minting coinsMint request submitted 可能会由于网络原因失败1234libra% account mint 0 1000&gt;&gt; Minting coins[ERROR] Error minting coins: error trying to connect: failed to lookup address information: Name or service not known 给B账户铸币50123libra% account mint 1 50&gt;&gt; Minting coinsMint request submitted 查询账户余额12345libra% query balance 0Balance is: 1000libra% query balance 1Balance is: 50 发起转账交易查询账户的sequence，由于两个账户都没有交易记录，所以都是0123456libra% query sequence 0&gt;&gt; Getting current sequence numberSequence number is: 0libra% query sequence 1&gt;&gt; Getting current sequence numberSequence number is: 0 从A给B转账1001234libra% transfer 0 1 100&gt;&gt; TransferringTransaction submitted to validatorTo query for transaction status, run: query txn_acc_seq 0 0 &lt;fetch_events=true|false&gt; 查询账户余额：1234libra% query balance 0Balance is: 900libra% query balance 1Balance is: 150 再次从A给B转账10012345libra% transferb 0 1 100&gt;&gt; Transferring[waiting Transaction completed, found sequence number 2]Finished transaction!To query for transaction status, run: query txn_acc_seq 0 1 &lt;fetch_events=true|false&gt; 再查询账户余额：1234libra% query balance 1Balance is: 250libra% query balance 0Balance is: 800 查询A和B账户的sequence， A的账户sequence number是2表示A发起了两个交易，B账户的sequence number是0表示B账户没有发起交易123456libra% query sequence 0&gt;&gt; Getting current sequence numberSequence number is: 2libra% query sequence 1&gt;&gt; Getting current sequence numberSequence number is: 0 可以使用 query txn_acc_seq 0 0 true查询详细的转账信息:12345678910111213141516171819202122232425libra% query txn_acc_seq 0 0 true&gt;&gt; Getting committed transaction by account and sequence numberCommitted transaction: SignedTransaction &#123; raw_txn: RawTransaction &#123;truesender: 1b7f0e3123d52cd4b80d451da785a1db96a5ec6a9cdcd84d5d344341b8e77158,truesequence_number: 0,truepayload: &#123;,truetruetransaction: peer_to_peer_transaction,truetrueargs: [truetruetrue&#123;ADDRESS: fc5fecde4dee37102a49085725f5d4491d9e9cda00afba078988eba0696c4691&#125;,truetruetrue&#123;U64: 100000000&#125;,truetrue]true&#125;,truemax_gas_amount: 10000,truegas_unit_price: 0,trueexpiration_time: 1561190218s,&#125;, public_key: 2a9c5aa44975912b7eda3bc9df6047d19dd5f4937404bade1f922acce9cab42c, signature: Signature( R: CompressedEdwardsY: [203, 171, 64, 238, 247, 224, 54, 137, 221, 158, 125, 30, 230, 58, 66, 151, 147, 23, 112, 148, 192, 216, 201, 210, 123, 53, 94, 96, 129, 180, 182, 126], s: Scalar&#123;truebytes: [71, 53, 181, 160, 59, 152, 34, 26, 218, 59, 72, 202, 235, 202, 104, 248, 52, 52, 53, 191, 171, 105, 222, 117, 50, 57, 155, 35, 206, 52, 185, 14],&#125; ), &#125;Events:ContractEvent &#123; access_path: AccessPath &#123; address: 1b7f0e3123d52cd4b80d451da785a1db96a5ec6a9cdcd84d5d344341b8e77158, type: Resource, hash: "217da6c6b3e19f1825cfb2676daecce3bf3de03cf26647c78df00b371b25cc97", suffix: "/sent_events_count/" &#125; , index: 0, event_data: AccountEvent &#123; account: fc5fecde4dee37102a49085725f5d4491d9e9cda00afba078988eba0696c4691, amount: 100000000 &#125; &#125;ContractEvent &#123; access_path: AccessPath &#123; address: fc5fecde4dee37102a49085725f5d4491d9e9cda00afba078988eba0696c4691, type: Resource, hash: "217da6c6b3e19f1825cfb2676daecce3bf3de03cf26647c78df00b371b25cc97", suffix: "/received_events_count/" &#125; , index: 0, event_data: AccountEvent &#123; account: 1b7f0e3123d52cd4b80d451da785a1db96a5ec6a9cdcd84d5d344341b8e77158, amount: 100000000 &#125; &#125; Over!]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git仓库的多个子目录独立成一个新仓库]]></title>
    <url>%2F2019%2F05%2F17%2FGit%E4%BB%93%E5%BA%93%E7%9A%84%E5%AD%90%E7%9B%AE%E5%BD%95%E7%8B%AC%E7%AB%8B%E6%88%90%E6%96%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[需求描述我有一个仓库AAA，目录结构如下：12345678$ tree├── .git├── common-api ├── commons-pojo├── commons-utils ├── account └── payment └── product 现在我需要把common-api、commons-pojo、commons-utils独立为一个新仓库xxx-common从网上找到可以用”git filter-branch”和”git subtree split”两种方式独立目录为仓库，但是”git subtree split”只能独立一个目录为仓库，如果需要独立多个目录为仓库需要使用”git filter-branch”。 实施步骤1. Clone原有仓库到本地1git clone git@192.168.0.xxx:test/AAA.git 2. 在本地创建需要保留的分支下面示例中保留了dev和feature_20190516_xxx_aaa_bbb12git checkout -b dev origin/devgit checkout -b feature_20190516_xxx_aaa_bbb origin/feature_20190516_xxx_aaa_bbb 3. 取消远程库的关联1git remote rm origin 4. 删除所有tag需要删除所有的tag，否则会出错1git tag -l | xargs git tag -d 5. 保留需要的目录和git历史把”GIT_COMMIT –”后面的目录改为自己需要保留的12git filter-branch -f --prune-empty --index-filter \ 'git rm --cached -r -q -- . ; git reset -q $GIT_COMMIT -- commons-api commons-pojo commons-utils' -- --all 6. 清理仓库并减小体积1234git reset --hardgit for-each-ref --format="%(refname)" refs/original/ | xargs -n 1 git update-ref -dgit reflog expire --expire=now --allgit gc --aggressive --prune=now 7. 关联到新的远程库(空仓库)，并推送代码到远端1234git remote add origin git@192.168.0.xxx:test/xxx-common.gitgit push -u origin mastergit push -u origin devgit push -u origin feature_20190516_xxx_aaa_bbb]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上线发布流程]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%B8%8A%E7%BA%BF%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[上线发布流程图 计划阶段在迭代完成前半周的会议上确认迭代是否需要发布版本，如果需要则制定发布计划并确定是否需要做回归测试 是否需要回归测试？12345现有的分支模型为开发直接从Master拉取feature分支，测试从Master拉取release/test分组然后合并feature branch到release/test形成测试分支上线前如果Master分支上没有其他feature上线，则直接使用release/test打包上线以下情况需要回归测试：上线前如果Master分支上有其他feature上线，则从Master拉取release/pro并合并相关feature branch打包上线，并进行回归测试 发布策略能做灰度发布尽量灰度，并且设计开关，有些Bug在测试环境测不出来 常见策略： 灰度/金丝雀 滚动发布 蓝绿发布 上线审批使用邮件或者TAPD流程进行审批 如下为内容框架： 上线时间 上线内容 影响范围 影响到的服务 数据变更说明 配置变更说明 详细操作步骤(测试和运维可以操作的step by step说明) 上线注意事项 数据监控 上线后 线上验收 验证特性的正确性 验证所有业务流程 检查各项数据的正确性 数据监控 线上数据的正确性 临界值监控]]></content>
  </entry>
  <entry>
    <title><![CDATA[线上问题处理流程]]></title>
    <url>%2F2019%2F04%2F15%2F%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[问题处理流程 问题反馈渠道一般都是通过邮件、聊天群、私聊等途径反馈，尽量让监控系统及时发现问题 监控系统 – 所有问题应该尽量从这里暴露出来 客服 运营人员 业务管理部门 其他 问题收集 收集：所属业务、模块、影响范围、发生时间、严重程度等 初步判断发生原因 在”线上问题研发跟进”微信群中@相关开发人员 问题跟踪 严重问题，”线上问题研发跟进”@开发人员后&gt;10分钟无响应，电话联系相关主要负责人沟通跟进 非严重问题，”线上问题研发跟进”@开发人员后&gt;30分钟无响应，电话联系相关主要负责人沟通跟进 开发人员判断是问题，录入Issue到TAPD，并发送链接到微信群”线上问题研发跟进” 开发人员判断问题严重，则需要在研发响应群中告知问题及影响范围，并及时召集人员讨论处理 开发人员处理Bug应及时更新状态到TAPD中，并告知相关人员对当前工作进度的影响 后续优化问题处理完成后应该讨论是否需要优化现有的业务逻辑或代码，主要是为了消除问题影响、避免技术债务、提升体验。 例行问题分析 周会 分析一周线上问题 月度质量分析会议 12345问题汇总分析 -- 按问题来源、模块及归属问题解决时长分析未关闭问题：处理进度、优化的方案讨论关键流程分析，如：XX业务的响应时间、成功率、错误码占比、用户的操作习惯等]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>研发</tag>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[研发协作流程]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%A0%94%E5%8F%91%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[协作流程图 需求评审一般由项目负责人/Scrum Master发起，项目组所有成员参与。 阶段目标 所有成员详细了解需求方案及需求的关键点。 要做的准备 提前一天发评审会邀和相关文档 提前看需求文档，了解需求内容 熟悉相关业务和代码 解决的问题 项目所有成员统一需求认知 初步评估需求方案，技术可行性 预估项目容量 技术方案评审技术方案的设计，一般由研发负责人或者项目技术负责人发起。 开发必须经过技术方案评审，和需求挂钩，明确回答“怎么做” 阶段目标 梳理所有技术点的实现方案 要做的准备 提前一天发评审邀请和相关文档 提前评估各自的实现方案 复杂的技术点，需要提前沟通 解决的问题 项目组成员间沟通技术实现方案 确定各端交互的方式，以文字的形式留存 评估详细排期 评估排期采用文档协作的方式来分解任务和评估排期。比如使用tencent docs或者google docs。 阶段目标 输出全员无异议的开发计划，记录到项目管理工具(TAPD)并通过邮件发出. 注意点： 对需求进行尽量细的功能点拆分，有助于准确评估排期（精确到0.5天） 根据实际项目情况，预留适当的buffer时间（大约为项目总时长的5% ~ 10%） 排期一旦确定，视为对所有成员的承诺，非极端情况不可更改 排期计划规范 项目名称、参与项目人员、日期、开发功能点简述、项目天数 排期邮件由项目负责人汇总发出 邮件需知会参与项目各方同学及leader 项目开发 参考分支开发规范 先在YAPI平台定义接口，前端和测试使用Mock Server来开发前端及自动化测试接口，待后端接口提供后进行联调测试。 全部联调通过及单元测试通过后提交测试。 用例评审由QA同学发起，项目组成员全部参加，评审测试用例的准确性和完整性，一般在项目开发过程中进行，没有固定时间。 阶段目标 所有成员详细了解测试用例，并产出覆盖完整性高的测试用例。 要做的准备 提前一天发评审邀请和相关文档 明晰需求细节 了解测试用例 如果有负责的测试场景需要和开发一起制定解决方案 解决的问题 评估测试用例是否覆盖到所有情况，正常路径以及异常路径 借助测试用例回顾已经开发的内容和需求的细节 联调由后端或者前端人员发起，仅开发人员参与，尽可能利用一套统一的环境，进行联调。 阶段目标 调试完成全部需求需要完成的流程 联调规范 各功能开发完成则开始联调，是否可以分阶段联调视情况而定 有QA的项目，在联调过程中覆盖大多数测试用例 无QA的项目，开发人员整理测试用例，并在联调过程中尽可能覆盖 代码评审代码合并到主干之前应该经过 code review。 提测规范 提测给QA的代码必须通过自测和验收 提测分支若落后主干，同步之后再提测 提供编译后代码，保证与上线代码一致性 严禁使用QA环境调试bug 阻塞测试流程的bug及时修复 其余bug可定期统一修复 项目验收在测试环境通过或者上线后，由测试人员发起，邀请PM/UI/UE等角色，对产品进行全方位的验收。 阶段目标 保证需求没有遗漏，符合预期 正常流程没有问题，可以使用 验收规范 在单元测试完成和上线后发起 UI/UE进行视觉交互验收，PM进行功能验收 中大型项目排期时至少预留1天验收时间，一般预留半天验收时间]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[招聘流程]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%8B%9B%E8%81%98%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[招聘流程1HR推送简历-&gt;筛选简历-&gt;电话面试-&gt;技术面试-&gt;填写面试评估表格-&gt;Offer 筛选简历最多5分钟筛选一份简历，目的是尽量筛选掉不符合岗位需求的简历。 明确岗位需求 考察简历与岗位需求的匹配度 基本：年龄、性别、婚育、教育经历 重点：职位职责、工作经验、技术匹配度 电话面试不超过30 分钟，快速过滤明显不符合岗位要求的人，节省双方的时间成本。 大致流程： 浏览候选人简历，对其中有疑问的地方如：跳槽频繁、职业经历空档、学历问题或其他疑问事先划线标出来 双方选手相互介绍后，先核对一下简历的细节，如果公司有隐性的标准比如学历、工作经验年限、婚育等可以问到 就过完工作经验与岗位匹配度进行判断，过程中考察其语言表达和逻辑能力等细节。 聊聊离职动机与期望薪资以及候选人对职业的发展规划 结束电话面试。 技术面试 第一轮 面试官：1~2个，技术Leader/高级工程师 基础 - Java基础，数据结构，算法，网络，操作系统等 深度原理 - 就了解、做过、学习过的技术框架、中间件进行灵魂拷问 逻辑题 给出问题，在纸/电脑上写程序 第二轮 面试官：2个，技术Leader/高级工程师 + 其他组的高级工程师(比如面试后台则为测试或者前端) 针对以往的项目经验及做过的技术方案进行考察 针对沟通能力和协作能力做考察 终试 技术负责人复试 离职动机薪资期望 职业规划、发展方向、学习能力、领导力等 让对方提问 面试中碰到好的候选人，在面试结束时可以对他们说：“最迟在两天内可以收到我们的通知，如果没有请直接联系我或者HR”。如果对这个人不是很感兴趣，可以直接拒绝。 填写面试评估表格面试完毕记得填写评估表格，可以提供后续面试参考以及回溯比较作用，表格存放在共享文档系统(tencent/google docs)中。 电话面试评估表：记录项值：[符合、不符合] [基本匹配、匹配度高、不匹配] 候选人 面试官 基本条件 职位职责 工作经验 技术能力 张三 小明 符合 符合 匹配 匹配 李四 老赵 符合 不符合 匹配度高 匹配 技术面试评估表：四个等级：优秀、良好、一般、较差 候选人 面试官 基础技术 逻辑能力 沟通能力 协作能力 张三 三丰、逍遥 良好 一般 优秀 良好 李四 紫霞、玉帝 优秀 良好 优秀 良好 Offer通过比较选定候选人后，让HR谈薪资并发Offer]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ InactivityIOException]]></title>
    <url>%2F2019%2F04%2F09%2FActiveMQ-InactivityIOException%2F</url>
    <content type="text"><![CDATA[问题现象生产服务器上，ActiveMQ Produce和Consumer端同时报如下错误，导致不能正常工作。12019-03-26 23:01:18,815 | WARN | Transport Connection to: tcp://xx.xx.xx.xx:59582 failed: org.apache.activemq.transport.InactivityIOException: Channel was inactive for too (&gt;30000) long: tcp://xx.xx.xx.xx:59582 | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker 官网解释123The maximum inactivity duration (before which the socket is considered dead) in milliseconds. On some platforms it can take a long time for a socket to appear to die, so we allow the broker to kill connections if they are inactive for a period of time. Use by some transports to enable a keep alive heart beat feature. Set to a value &lt;= 0 to disable inactivity monitoring. 配置JMS连接最大闲置时间(消息服务器无消息)该wireFormat.maxInactivityDuration 的默认值是30000mswireFormat.maxInactivityDuration=0 这样的参数， wireFormat.maxInactivityDuration是心跳参数。避免ActiveMQ在一段时间没有消息发送时抛出 “Channel was inactive for too long”异常。 该异常会关闭连接，虽然client端会重连成功，但是不能发送数据，然后继续报下面异常：1[ WARN ] Transport (tcp://xx.xx.xx.xx:61616) failed, reason: java.net.SocketException: Connection reset, attempting to automatically reconnect 解决方案12设置wireFormat.maxInactivityDuration=0，禁用InactivityMonitor改为tcp://xx.xx.xx.xx:61616?wireFormat.maxInactivityDuration=0]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支模型(参考阿里Aone Flow)]]></title>
    <url>%2F2019%2F04%2F04%2FGit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[分支定义 master 123长期分支，存在与整个项目开发过程。由项目主要技术负责人管理该分支。 release/xxx 1234release/test 和 release/prod既可以为长期分支也可以为短期分支，可能存在于一个或者多个版本之间.由测试负责人负责人管理该分支。 feature/fixbug/hotfix 12345临时分支用于开发的具体功能特性和修复bug的分支，功能完成后删除.格式为：feature_$date_$name_$description fixbug_$date_$name_$description hotfix_$date_$name_$description 分支策略 规则1 开始工作前，从主干创建特性分支 每当开始一件新的工作项（比如新的功能或是bug）的时候，从最新已发布版本的主干Master上创建一个以feature(bugfix)/前缀命名的特性分支，然后在这个分支上提交代码修改。 每个工作项（可以是一个人完成，或是多个人协作完成）对应一个特性分支，所有的修改都不允许直接提交到主干。 规则2 通过合并特性分支，形成发布分支 从主干上拉出一条新分支，将所有本次要集成或发布的特性分支依次合并过去，从而得到发布分支。发布分支通常以release/前缀命名。 每条发布分支与具体的环境相对应，比如release/test分支对应部署测试环境，release/prod分支对应线上正式环境等等，并与流水线工具相结合，串联各个环境上的代码质量扫描和自动化测试关卡，将产出的部署包直接发布到相应环境上。 release/prod从master上拉取的时候master可能已经有其他更新上线了，此时从master拉取拉取的release/prod合并相关feature分支后需要进行回归测试。 规则3 发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支 完成了线上正式环境的部署，就意味着相应的功能真正地发布了，此时应该将这条发布分支合并到主干。 为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。 主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。 其他 对于hotfix，可以创建一条新的发布分支对应线上环境（相当于hotfix分支），同时为这个分支创建临时流水线，以保障必要的发布前检查和冒烟测试能够自动执行。 如果非得修一个历史版本的Bug，在主干分支找到版本标签位置，然后从那个位置创建hotfix分支，这种情况比较少见 开发流程 新功能开发时，开发人员从Master拉取代码生成特性分支。 单元测试完成后等待测试负责人拉取release/test分支，然后提交Pull Request 开发负责人或者其他开发人员对Pull Request进行代码Review 代码Review完成后，测试负责人合并Pull Request到release/test，如果遇到合并冲突，则让相应的开发人员把feature/bug/hotfix分支重新以master为基准进行提交以及让相应的开发人员协助解决。 测试人员使用流水线工具进行代码质量扫描和自动化测试 测试人员进行测试 完成测试后，查看Master是否比拉取release/test时有更新，如果没有直接使用release/test上线，否则从最新Master拉取分支release/prod分支合并相关PR并进行回归测试 提交上线申请上线 示例： 1234567891011开发人员A从Master拉取代码生成feature_20190818_A_get_users开发人员B从Master拉取代码生成feature_20190819_B_login测试负责人Y从Master拉取release/test开发人员A提交Pull Request PR1开发人员B提交Pull Request PR2开发负责人F和开发人员C评审PR1 PR2，评审通过测试负责人Y合并代码到release/test测试人员X进行测试，完成后发现Master和拉取release/test时一样，直接使用release/test进行构建申请发布]]></content>
      <categories>
        <category>管理</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构化行为面试法]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%BB%93%E6%9E%84%E5%8C%96%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95%E6%B3%95%2F</url>
    <content type="text"><![CDATA[准备 掌握候选人基本信息 123年龄、性别、学历、专业行业背景技术范围、工作经验 对候选人的期望值 123456技术要求 比如：Java基础扎实，熟悉分布式系统开发，对A、B、C、D技术熟练使用/掌握原理/有优化经验，实践过并发大于100的系统等能力素质 例如：沟通能力、协调能力、领导力等个性特质 例如：外向型、严谨、细致等，需要结合领导风格、团队风格、企业文化环境 最好公司有自己的能力素质模型 – 待整理 其他 1234列出提问的问题： 问题要求：清晰、准确、易理解 多维度： 项目经验、技术能力、沟通、协作、规划等面试流程(确定面几轮、谁来面？如何决策) 开场 暖场 暖场的作用在于减少候选人的压力，便于后续从面试的过程中获取真实的行为事例。 暖场话术示例(继续补充)： 12345茶水或者咖啡？天气状况，适宜出游 or 太热太冷只可宅？路况如何，到达公司所需时长，是否顺利？哪里人，靠近什么名胜或者有什么特产？(注意避免地域性偏见)毕业于什么学校，学校有什么有名的人物或者事迹？ 开篇话术 介绍自己、面试流程和面试重点 示例： 1234面试官：您好，王先生，请坐。自我介绍一下，我是今天的面试官XXX，这位是YYY，欢迎来参加今天的面试。求职者：谢谢。面试官：面试的过程中我们会提出一些问题，请您以过去经历当中的具体事例来回答，而这部分将占用大部分的面谈时间，在回答的过程中请注意简明扼要、抓住重点。需要说明的是面试的过程中我会视情况调整话题，以确保多谈一些您过往曾经做过的事情。最后我会留一些时间让您询问跟这份工作以及我们公司相关的问题。我们现在正式开始，OK？ 对方自我介绍 注意倾听不要打断，有问题等介绍完再去问。 问问题 提问话术 问题短而精，基于事的行为问题（为什么这么做），少问假设性问题 标准化能力行为提问： 1234请谈谈 你在工作中快速掌握新知识的 一些经验请举 一个 体现"沟通能力"的 栗子 请描述 一件 在跨部门合作成功的 经历请举 一个 证明你有效与人合作并共同完成了一件重要的事情的 栗子 过去行为示例： 1234请举例说明 你过往是如何 获得了XX技能并把该技能转化到实际工作中请举例说明 你过往是如何 处理线上突发的Bug请举例说明 你过往是如何 进行Code Review请举例说明 你过往是如何 帮助下属/同事成长 过去行为示例： 123456789分享一下 你在过往工作 所使用的git分支模型分享一下 你在过往工作 所做过的MYSQL优化分享一下 你在过往工作 所做过的技术分享讲述一下 你在上一份工作中遇到的最难解决的问题 你是怎么处理的？回忆 你在同一时间内需要同时处理多项工作时 你是如何处理的？在过去 你和领导意见不一致时 你是如何处理的？分享一下 你在面对新的工作环境时 你是怎么处理的？分享一下 你在过往工作中最有价值的一件事 当时你是怎么做的？分享一下 你在遇到服务/Mysql变慢的问题时 你是怎么处理的？ 如何避免面试中出现的虚假的回答？ 运用STAR进行有效追问，面试官需要敏锐地观察并进行细节追问，追问的目的在于获取行为事例或者对不完整事例进行补充 1234S指情景（Situation）：这件事发生的时间、地点、人物等背景介绍。T指任务（Task）：这件事情发生在什么场景下，你要完成什么任务，面对什么抉择或者困难？A指行动（Action）：你扮演什么角色？做了哪些事情？R指结果（Result）：事情的结果如何？你收到了什么反馈？ 层层递进问题法 针对候选人的项目经验和过往的技术能力问题层层递进，直到候选人答不上来为止 比如HashMap： 123456789101112HashMap的使用场景为什么用HashMapHashMap的原理HashMap的初始化、增长、键值获取HashMap如何减少碰撞Hash函数如何实现为什么改为红黑树，不用二叉树 -&gt; 为什么不一致用红黑树HashMap有序嘛 -&gt; 有没有有序的Map -&gt; 有序的Map怎么实现的,怎么保证有序性HashTable和HashMap的区别ConcurrentHashMap可以完全替代Hashtable嘛ConcurrentHashMap的版本迭代中发生了哪些变动，各个版本都有什么问题ConcurrentHashMap用到的锁的逻辑部分是怎么实现的 候选人：我是谁？我为什么要来面试？这个面试官太强了吧… 逻辑能力+写代码针对技术面试一定要有逻辑能力和代码能力的部分 逻辑题 例如(继续补充)： 1234马路上的井盖为什么是圆的？有人把车停在旅馆外，丢失了他的财物，他接下来会干什么？你需要确认朋友Bob是否有你正确的电话号码，但不能直接问他。你须在一张卡片上写下这个问题，然后交给Eva，由Eva把卡片交给Bob，再转告你答案。除了在卡片上写下这个问题外，你还必须怎样写，才能确保Bob在给出答案的同时，不让Eva知道你的电话号码？假设你是海盗船的船长，船员们即将对黄金的分配方案投票。如果赞成票不到半数的话，你会被杀死。你怎样才能在保证自己存活的情况下拿到最多的黄金？ 算法题 例如(继续补充)： 12345排序算法哈希算法红黑树合并有序链表约瑟夫问题(求最后一个人序号、求最小的m使得K个被处决K个不被处决) 其他代码能力 例如(继续补充)： 1234写一个生产者消费者模式写一个死锁写一个你认为最好的单例模式给盲人设计一个ATM/电梯 评估表现(待补充) 依据上述记录的事实来进行多维度评估 填写表格并作出相应的决定 使用公司拥有的能力模型来设计打分表，并进行结果评估，然后做出候选人对比。]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>招聘</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带新员工]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%B8%A6%E6%96%B0%E5%91%98%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[导图 注意点 遵从 PDCA(Plan-&gt;Do-&gt;Check-&gt;Action) 的原则 就计划达成一致并讲解计划 引导思考，最终可以自己寻找找到解决方案(给答案-&gt;给线索-&gt;自己摸索) 进行阶段性检查，确保计划执行的正确性，解决过程中遇到的问题以及对计划做出调整 以身作则，多肯定和鼓励引导做出正确的选择和避免犯错，多沟通并积极主动去完成每一件事。 用心、有耐心以及有责任心。 …待补充]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导师制]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%AF%BC%E5%B8%88%E5%88%B6%2F</url>
    <content type="text"><![CDATA[目的传道授业解惑 帮助新员工熟悉环境、业务以及进行例行化工作指导 在各个阶段观察和帮助新员工，避免工作不饱和，不明确工作目标。 传递公司的价值观和规章制度，绩效考核制度等等关键信息 帮助新员工融入新的集体，快速融入公司的节奏。 及时发现新员工是否满足工作要求，做出及时的调整 导师的选拔条件 在公司工作一年以上，绩效必须好 部门业务骨干，有能力进行业务指导 充分认可公司文化，有能力进行思想引导 为人正直热情，责任心强，有较强的计划、组织、管理、沟通能力，有能力为新员工制定合理的计划、安排相应的工作任务 一名导师名下不能超过两个学生 导师奖惩 以补助的形式给导师每月XXX元的“导师费” 定期评选“优秀导师”，被评为“优秀导师”的可得到公司XXX元的奖励 连带责任，如果徒弟犯了错误导师连带追责，甚至降职 没有担任过导师的员工，不得提拔为行政干部；不能继续担任导师的，不能再晋升 导师的管理主体 部门Leader、总监 人力资源部 主要内容 业务知识培训 开发规范和流程培训 需要使用到的相关技术培训 公司相关制度 可能的周期和计划 第一月：熟悉环境，制定计划，开发规范和业务培训 第一天：帮助熟悉工作环境 第一周：制定培养计划，布置工作和学习任务 第二周：主动询问，有问必答 第一月末：沟通，总结，做计划 第二月：安排工作，监督学习成果和工作绩效，及时就计划是否需要修改作出沟通 第三月：安排工作，监督学习成果和工作绩效，及时就计划是否需要修改作出沟通 … 帮助转正答辩]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7下Cloudera Manager及CDH 6.1.0安装过程详解]]></title>
    <url>%2F2019%2F03%2F25%2FCM-CDH6.1.0%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、概念介绍1、CDH 概览CDH是Apache Hadoop和相关项目的最完整、最受测试和最流行的发行版。CDH提供Hadoop的核心元素-可伸缩存储和分布式计算-以及基于web的用户界面和重要的企业功能。CDH是Apache许可的开放源码，是唯一提供统一批处理、交互式SQL和交互式搜索以及基于角色的访问控制的Hadoop解决方案。 CDH 提供以下特性： 灵活性：存储任何类型的数据并使用各种不同的计算框架进行操作，包括批处理、交互式SQL、免费文本搜索、机器学习和统计计算。 集成：在一个完整的Hadoop平台上快速启动和运行，该平台与广泛的硬件和软件解决方案一起工作。 安全：处理和控制敏感数据。 可伸缩性：启用广泛的应用程序和规模，并扩展它们以满足您的需求。 高可用性：满怀信心地执行任务关键的业务任务。 兼容性：利用您现有的IT基础设施和投资。 CDH 组件如下图： 2、Cloudera Manager 概览Cloudera Manager 是用于管理cdh集群的端到端应用程序。Cloudera Manager通过向CDH集群的每个部分提供细粒度的可见性并对其进行控制来设置企业部署标准-授权运营商提高性能、提高服务质量、提高遵从性和降低管理成本。使用Cloudera Manager，您可以轻松地部署和集中操作完整的CDH堆栈和其他托管服务。应用程序自动化安装过程，将部署时间从数周减少到分钟；为您提供在集群范围内运行主机和服务的实时视图；提供一个单一的中央控制台来执行整个集群的配置更改；并集成各种报告和诊断工具，以帮助您进行操作。 Cloudera Manager 的架构如上图所示（cs结构），主要由如下几部分组成： 服务端/Server：Cloudera Manager 的核心。主要用于管理 web server 和应用逻辑。它用于安装软件，配置，开始和停止服务，以及管理服务运行的集群。 代理/agent：安装在每台主机上。它负责启动和停止的进程，部署配置，触发安装和监控主机。 数据库/Database：存储配置和监控信息。通常可以在一个或多个数据库服务器上运行的多个逻辑数据库。例如，所述的 Cloudera 管理器服务和监视，后台程序使用不同的逻辑数据库。 Cloudera Repository：由cloudera manager 提供的软件分发库。 客户端/Clients：提供了一个与 Server 交互的接口。 Cloudera Manager包括server端和agent；server端主要作用是监控集群分发配置集群等，agent端主管集群各节点。CDH是CM的安装包，本地或者云端，其中包括hadoop的生态系统需要的所有组件，通过Cloudera Manager统一管理和安装。CDH除了可以通过cm安装也可以通过yum,tar,rpm安装。 二、环境准备1、软件版本选择 类目 版本 下载地址 操作系统 CentOS Linux release 7.5.1804 (Core) 阿里云或者其他 数据库 MySQL 5.7.25 官网下载 JDK jdk-8u202-linux-x64.rpm Oracle 官网下载 Cloudera Manager Cloudera Manager 6.1.0 官方地址 CDH CDH 6.1.0 使用parcels安装 2、节点准备（四个节点） 名称 IP CM管理软件 namenode1 192.168.0.23 Cloudera Manager Server&amp;Agent ，MySQL datanode1 192.168.0.70 Cloudera Manager Agent datanode2 192.168.0.74 Cloudera Manager Agent datanode3 192.168.0.155 Cloudera Manager Agent 3、配置主机名和hosts解析(所有节点)编辑/etc/hostname，在每个节点上修改主机名(主机名不能出现下划线):1namenode1 1datanode1 1datanode2 1datanode3 在对应的节点上使用命令使其立刻生效：1hostnamectl set-hostname namenode1 1hostnamectl set-hostname datanode1 1hostnamectl set-hostname datanode2 1hostnamectl set-hostname datanode3 编辑文件/etc/hosts，增加如下内容(所有节点)。 1234192.168.0.23 namenode1192.168.0.70 datanode1192.168.0.74 datanode2192.168.0.155 datanode3 编辑 /etc/sysconfig/network(所有节点): 12NETWORKING=yesHOSTNAME=xxxnodexx 使用命令使其立刻生效1source /etc/sysconfig/network 4、关闭防火墙(所有节点)12systemctl stop firewalld.servicesystemctl disable firewalld.service 1firewall-cmd --state 5、关闭SELinux(所有节点)12sed -i 's\#SELINUX=enforcing\#SELINUX=disabled\#g' /etc/selinux/configsetenforce 0 1/usr/sbin/sestatus -v 6、添加定时任务(所有节点)1echo "$((RANDOM%60)) $((RANDOM%24)) \* \* \* /usr/sbin/ntpdate time1.aliyun.com" &gt;&gt; /var/spool/cron/root 7、禁用透明大页面压缩(所有节点)CDH配置需要 12echo never &gt; /sys/kernel/mm/transparent_hugepage/defragecho never &gt; /sys/kernel/mm/transparent_hugepage/enabled 并将上面的两条命令写入开机自启动/etc/rc.local。 8、优化交换分区(所有节点)12echo "vm.swappiness = 10" \&gt;\&gt; /etc/sysctl.confsysctl -p 9、配置 JDK (所有节点)卸载自带的OpenJdk：12rpm -qa | grep java #查询java相关的包rpm -e java*** --nodeps #根据查找到的软件包信息卸载 在Oracle官网下载JDK的RPM包1rpm -ivh jdk-8u202-linux-x64.rpm 10、安装数据库(namenode1)我们这里安装 MYSQL5.7.25，版本是支持的。 10.1 卸载自带mariadbcentos 7 默认安装的是mariadb，如果不卸载直接安装的话会报错。 12rpm -qa | grep mariadb #查看安装信息rpm -e mariadb-libs* --nodeps #根据查找到的软件包信息卸载 10.2 下载安装文件下载地址如下：1234https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-community-common-5.7.25-1.el7.x86_64.rpmhttps://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-community-libs-5.7.25-1.el7.x86_64.rpmhttps://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-community-client-5.7.25-1.el7.x86_64.rpmhttps://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-community-server-5.7.25-1.el7.x86_64.rpm 10.3 安装MySQL按以下顺序安装1234rpm -ivh mysql-community-common-5.7.21-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.21-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.21-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.21-1.el7.x86_64.rpm 如果出现以下缺少libnuma错误，请先安装libnuma1yum install libnuma* 10.4 设置数据库(namenode1)启动服务1service mysqld start 查看初始密码1vim /var/log/mysqld.log 修改密码mysql -uroot -p #使用mysqld.log中的临时密码登录1ALTER USER 'root'@'localhost' IDENTIFIED BY 'Root123!!!'; 授权用户root使用密码passwd从任意主机连接到mysql服务器12GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Root123!!!' WITH GRANT OPTION;flush privileges; 11、安装 MySQL JDBC 驱动(所有节点)用于各节点连接数据库。 123456wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.47.tar.gztar xf mysql-connector-java-5.1.46.tar.gzmkdir -p /usr/share/java/cd mysql-connector-java-5.1.47cp mysql-connector-java-5.1.47-bin.jar /usr/share/java/mysql-connector-java.jar 三、安装 CM 和 CDH1、配置 Cloudera Manager 仓库(namenode1)1.1. 下载rpm包CM主要下面的三个软件包： 12345cloudera-manager-agent-6.1.0-769885.el7.x86_64.rpmcloudera-manager-daemons-6.1.0-769885.el7.x86_64.rpmcloudera-manager-server-6.1.0-769885.el7.x86_64.rpmcloudera-manager-server-db-2-6.1.0-769885.el7.x86_64.rpmallkeys.asc 地址如下，下载完成放在cm6.1.0目录：12345https://archive.cloudera.com/cm6/6.1.0/redhat7/yum/RPMS/x86_64/cloudera-manager-agent-6.1.0-769885.el7.x86_64.rpmhttps://archive.cloudera.com/cm6/6.1.0/redhat7/yum/RPMS/x86_64/cloudera-manager-daemons-6.1.0-769885.el7.x86_64.rpmhttps://archive.cloudera.com/cm6/6.1.0/redhat7/yum/RPMS/x86_64/cloudera-manager-server-6.1.0-769885.el7.x86_64.rpmhttps://archive.cloudera.com/cm6/6.1.0/redhat7/yum/RPMS/x86_64/cloudera-manager-server-db-2-6.1.0-769885.el7.x86_64.rpmhttps://archive.cloudera.com/cm6/6.1.0/allkeys.asc CDH主要有如下几个文件：123CDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcelCDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcel.sha256manifest.json 地址如下，下载完成放在cdh6.1.0目录：123https://archive.cloudera.com/cdh6/6.1.0/parcels/CDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcelhttps://archive.cloudera.com/cdh6/6.1.0/parcels/CDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcel.sha256https://archive.cloudera.com/cdh6/6.1.0/parcels/manifest.json cloudera-manager-daemons 是 server 和 agent 必须安装的。 1.2 安装http服务12sudo yum -y install httpd sudo service httpd start 在浏览器输入服务器地址，检查是否启动成功。 1.3 制作本地repo在cm6.1.0 cdh6.1.0 同级目录输入如下命令：12createrepo cm6.1.0createrepo cdh6.1.0 将cm6.1.0 与cdh6.1.0移到/var/www/html目录下：1mv cm6.1.0 cdh6.1.0 /var/www/html 在浏览器中查看目录:http://ip/cm6.1.0http://ip/cdh6.1.0 1.3 制作本地repo源sudo vi /etc/yum.repos.d/cm.repo12345[cmrepo]name = cm_repobaseurl =http://ip/cm6.1.0/enable = truegpgcheck = false sudo vi /etc/yum.repos.d/cm.repo12345[cdhrepo]name = cdh_repobaseurl =http://ip/cdh6.1.0/enable = truegpgcheck = false 1.4 把repo源文件传输到其他节点12scp /etc/yum.repos.d/cm.repo root@datanodeX:/etc/yum.repos.d/scp /etc/yum.repos.d/cdh.repo root@datanodeX:/etc/yum.repos.d/ 2、安装 CM Server 和 Agent(所有节点) namenode1： 1yum install cloudera-manager-daemons cloudera-manager-agent cloudera-manager-server datanode0[1-3]： 1yum install cloudera-manager-daemons cloudera-manager-agent 3、为 Cloudera 各软件创建数据库(namenode1)使用root登陆数据库，创建以下数据库和账号。 123456789101112131415161718CREATE DATABASE scm DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON scm.* TO 'scm'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE amon DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON amon.* TO 'amon'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE rman DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON rman.* TO 'rman'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE hue DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON hue.* TO 'hue'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE metastore DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON metastore.* TO 'hive'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE sentry DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON sentry.* TO 'sentry'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE nav DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON nav.* TO 'nav'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE navms DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON navms.* TO 'navms'@'%' IDENTIFIED BY 'YZHdata2019!!!';CREATE DATABASE oozie DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;GRANT ALL ON oozie.* TO 'oozie'@'%' IDENTIFIED BY 'YZHdata2019!!!'; 4、设置 Cloudera Manager 数据库(namenode1)123456789[root@namenode1 ~]# /opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scmEnter SCM password: YZHdata2019!!!JAVA_HOME=/usr/java/jdk1.8.0_162Verifying that we can write to /etc/cloudera-scm-serverCreating SCM configuration file in /etc/cloudera-scm-serverExecuting: /usr/java/jdk1.8.0_162/bin/java -cp /usr/share/java/mysql-connector-java.jar:/usr/share/java/oracle-connector-java.jar:/usr/share/java/postgresql-connector-java.jar:/opt/cloudera/cm/schema/../lib/* com.cloudera.enterprise.dbutil.DbCommandExecutor /etc/cloudera-scm-server/db.properties com.cloudera.cmf.db.[ main] DbCommandExecutor INFO Successfully connected to database.All done, your SCM database is configured correctly! 5、安装 CDH5.1 配置CDH的软件包 parcels(namenode1)把下载的CDH相关文件copy到/opt/cloudera/parcel-repo/目录123cp /var/www/html/cm6.1.0/CDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcel /opt/cloudera/parcel-repo/cp /var/www/html/cm6.1.0/CDH-6.1.0-1.cdh6.1.0.p0.770702-el7.parcel.sha256 /opt/cloudera/parcel-repo/cp /var/www/html/cm6.1.0/manifest.json /opt/cloudera/parcel-repo/ 修改属主属组1chown cloudera-scm.cloudera-scm /opt/cloudera/parcel-repo/* 5.2 启动 Cloudera Manager Server1systemctl start cloudera-scm-server 如果启动中有什么问题，可以查看日志。 1tail -f /var/log/cloudera-scm-server/cloudera-scm-server.log 在最后显示的日志中，有显示启动监听的端口。 12Started ServerConnector@da518cb&#123;SSL,[ssl, http/1.1]&#125;&#123;0.0.0.0:7183&#125;Started ServerConnector@a77165b&#123;HTTP/1.1,[http/1.1]&#125;&#123;0.0.0.0:7180&#125; 四、初始化 Cloudera Manager浏览器打开http://192.168.0.23:7180，用户名和密码默认都是admin。 接收许可。 这里我们选择免费版，收费版请自行选择。 五、集群安装指定要添加的节点。 选择存储库，之前我们已经在 CM Server 节点配置好了。 不进行勾选，选择我们自己安装的 JDK。 提供 SSH 登录凭据。 安装 agents，因为之前我们已经安装了，所以这里速度会很快。 安装选定的Parcel，之前我们已经下载好，并配置好放在的 CM Server 节点的/opt/cloudera/parcel-repo。 检查主机正确性。 六、集群设置选择要安装的服务，可以根据自己的需求进行软件安装。 自定义角色分配。 数据库设置。 审核更改，如果有特定目录的设定或者参数的设定，可以在这里进行更正。 首次运行。 安装完成。 七、管理集群首页Dashboard。 HDFS。 HBase。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>CDH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTfule API规范]]></title>
    <url>%2F2018%2F10%2F22%2FRESTful-API%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[REST RESTful本身是一种风格而不是规范，本文为该风格的规范实现的最佳实践，本文档详细说明了HTTP RESTful API的定义和使用规范，作为接口调用者和实现者的重要参考。 接口风格遵循RESTful设计风格，同时控制复杂度及易于使用，仅遵循大部分原则。 遵循原则： 使用https协议 版本号放入URL或Header 只提供json返回格式 post,put上使用json作为输入 使用http状态码作为错误提示 Path（路径）尽量使用名词，不使用动词，把每个URL看成一个资源 使用HTTP动词（GET,POST,PUT,DELETE）作为action操作URL资源 过滤信息 limit：指定返回记录数量 offset：记录开始位置 direction：请求数据的方向，取值prev-上一页数据；next-下一页数据 page：第几页 per_page：每页条数 total_count：总记录数 total_pages：总页数，等于page时，表示当前是最后一页 sort：column1,column2排序字段 orderby：排序规则，desc或asc q：搜索关键字（uri encode之后的） 返回结果 GET：返回资源对象 POST：返回新生成的资源对象 PUT：返回完整的资源对象 DELETE：返回一个空文档 速率限制 X-RateLimit-Limit: 每个IP每个时间窗口最大请求数 X-RateLimit-Remaining: 当前时间窗口剩余请求数 X-RateLimit-Reset: 下次更新时间窗口的时间（UNIX时间戳），达到下个时间窗口时，Remaining恢复为Limit 未遵循原则： Hypermedia API（HATEOAS），通过接口URL获取接口地址及帮助文档地址信息 限制返回值的域，fields=id,subject,customer_name 缓存，使用ETag和Last-Modified 参考： GitHub api ruanyifeng blog best-practices-for-a-pragmatic-restful-api 模块和版本说明接口模块相互对立且有版本管理，模块名作为APP配置项进行存储，每个模块的版本号version和endpoint在应用初始化时调用api模块信息接口（通过传递客户端应用名称和版本号获取各个API模块的endpoint和version）获取并存储。 示例模块及最新版本号： 模块模块用途最新版本号account帐户v1sms短信v1open一些开放接口，不需要公共参数v1 公共参数Headers公共请求参数是指每个接口都可能需要传递的参数，公共参数通过header传递。 参数是否必须说明及header格式app所有接口必须请求客户端应用标识，取值*-ios、*-android、*-pc、*-h5header格式：X-Co-App: $appuser_idApp登录后所有接口都传，Web通过session机制获取用户标识header格式：Authorization: CoAPI base64(user_id:token)tokenApp登录后所有接口都传，Web通过session机制获取授权访问令牌header格式：Authorization: CoAPI base64(user_id:token) Web应用通过cookies传递session id，user_id和token无需传递，接口会从session自动获取； 同一token值在App和Web各应用间通用（token即为session id）； APP修改user-agent，在原有user-agent的尾部添加$app/$version和NetType/$value。如： Dalvik/2.1.0 (Linux; U; Android 6.0.1; MI 4LTE MIUI/V7.5.3.0.MXGCNDE) $app-android/3.0.0 NetType/4G Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_2 like Mac OS X) AppleWebKit/603.2.4 (KHTML, like Gecko) $app-ios/3.0.0 NetType/WIFI app取值及释义示例 app取值客户端名称【域名】admin-pc管理中心PC网页版【admin.url.com】admin-h5管理中心手机网页版【admin.url.com】admin-ios管理中心iOS版admin-android管理中心Android版 Cookies 用于告知服务端是否支持Webp的Cookie：cookie name是supportWebp，取值是1（支持）和0（不支持），未传递时服务端默认取值为0。 Webview植入Session的Cookie： JWT &amp; OAuth2 Json Web Token可用于替代session-cookie机制。但会存在一些问题，比如为过期token强制失效问题（用户修改了密码后，无法强制其他的终端token全部失效）。 OAuth2是授权其他开发者访问自己应用有限权限的授权机制。 权限 权限分为 none：无需任何授权； token：需要用户登录授权，可通过header Authorization和Cookie CoSID传递； admintoken：需要管理员登录授权，可通过header Authorization和Cookie CoCPSID传递； token || admintoken：用户登录授权或管理员登录授权都可以； sign：需要签名，一般用于服务端内部相互调用。 状态码说明正确接口正常访问情况下，服务器返回2××的HTTP状态码。 HTTP状态码200 OK - 表示已在响应中发出、资源更改成功（GET、PUT）201 Created - 新资源被创建（POST）204 No Content - 资源被删除（DELETE） 错误当用户访问接口出错时，服务器会返回给一个合适的4××或者5××的HTTP状态码；以及一个application/json格式的消息体，消息体中包含错误码code和错误说明message。 5××错误(500=&lt;status code)为服务器或程序出错，客户端只需要提示“服务异常，请稍后重试”即可，该类错误不在每个接口中列出。 4××错误(400=&lt;status code&lt;500)为客户端的请求错误，需要根据具体的code做相应的提示和逻辑处理，message仅供开发时参考，不建议作为用户提示。 部分错误示例： codemessageHTTP状态码InvalidToken未登录或授权过期，请登录401 UnauthorizedValidationError输入字段验证出错，缺少字段或字段格式有误422 Unprocessable EntityAccountNotExist账户名不存在404 Not FoundInvalidPassword密码错误401 UnauthorizedNotFound请求的资源不存在404 Not FoundAccountHasExist账户名已经存在409 ConflictMobileHasBinded手机号已经绑定其他账户409 ConflictInvalidSign参数签名验证未通过403 ForbiddenInvalidSMSCode短信验证码错误403 ForbiddenExpiredSMSCode过期的短信验证码403 ForbiddenFrequencyLimit发送过于频繁，请稍后再试403 ForbiddenTimesExceeded达到最大发送次数限制，请明天再试403 ForbiddenVerifyTimesExceeded达到最大校验次数，请明天再试403 ForbiddenRateLimitExceeded接口调用次数超过限制，请稍后再试429 Too Many Requests InternalError服务异常，请稍后再试500 Internal Server Error HTTP状态码参考 参数传递遵循RESTful规范，使用了GET, POST, PUT, DELETE共4种请求方法。 GET：请求资源，返回资源对象 POST：新建资源，返回新生成的资源对象 PUT：新建/更新资源，返回完整的资源对象 DELETE：删除资源，返回body为空 GET请求不允许有body， 所有参数通过拼接在URL之后传递，所有的请求参数都要进行遵循RFC 3986的URL Encode。 DELETE删除单个资源时，资源标识通过path传递，批量删除时，通过在body中传递JSON。 POST, PUT请求，所有参数通过JSON传递，可选的请求参数，只传有值的，无值的不要传递，contentType为application/json。 4种请求动作中，GET、PUT、DELETE是幂等的；只有POST是非幂等的。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。 是非幂等是判断接口使用POST还是PUT的决定条件 注意： APP端获取json数据时，对于数值类型字段必须以数值类型转换，无论传递过来的值是否带引号。 速率限制Rate Limiting 为了防止API被恶意调用，对API调用进行速率限制。 速率限制为每IP每15分钟5000次（dev/qa为10W）调用（15分钟是一个时间窗口）。 限制是针对所有接口模块一起计算的（Redis key为APIRL:{IP}），暂时没有特殊的模块或单个接口（未来可能有）。 你可以通过每个接口返回的HTTP headers了解当前速率限制的情况: X-RateLimit-Limit: 每个IP每个时间窗口最大请求数 X-RateLimit-Remaining: 当前时间窗口剩余请求数 X-RateLimit-Reset: 下次更新时间窗口的时间（UNIX时间戳），达到下个时间窗口时，Remaining恢复为Limit 超出速率限制，返回以下错误 安全注意事项 用户登录后用户的token；aliyun OSS的bucket、AccessKey ID与AccessKey secret；微视频的appid、sign、bucket；这些关键数据通过调用接口获得，需要在客户端以安全的方式存储。 音频视频在APP内的存储，不允许被拷贝（即使越狱或root后拿走也无法使用）。 测试工具推荐Chrome浏览器插件Postman作为接口测试工具， Postman下载地址 文档生成工具 生成的工具为apidoc，详细阅读官方文档：http://apidocjs.com 调用示例 伪代码 PHP API模块信息获取 App配置文件中仅存储api模块名，App初始化时请求获取api模块信息，获取各个api模块的信息（endpoint和version）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>REST</tag>
      </tags>
  </entry>
</search>
